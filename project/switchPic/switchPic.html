<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Switch Picture</title>
	<style>
		* {
		  margin: 0;
		  padding: 0;
		}

		body {
		  background: #fafafa;
		  background: url('./images/bg.png')
		}

		::-webkit-scrollbar {
		  display: none;
		}

		#wrap {
		  width: 1065px;
		  padding-top: 50px;
		  margin: 0 auto;
		  padding: 30px;
		  background: rgb(255, 255, 255);
		  border-radius: 2px;
		  margin-top: 100px;
		}

		/* 整体容器 */
		.__Img__container {
		  font-size: 10px;
		}

		/* 分类容器 */
		.__Img__container .__Img__classify {
		  /* text-align: center; */
		}

		/* 分类按钮 */
		.__Img__container .__Img__classify .__Img__classify__type-btn {
		  display: inline-block;
		  padding: .2em 1em;
		  font-size: 1.6em;
		  margin-right: 10px;
		  cursor: pointer;
		  border: 1px solid #e95a44;
		  outline: none;
		  color: #e95a44;
		  transition: all .4s;
		  user-select: none;
		  border-radius: 2px;
		}

		/* 激活状态的分类按钮 */
		.__Img__container .__Img__classify .__Img__classify__type-btn.__Img__type-btn-active {
		  background: #e95a44;
		  /* border: 1px solid #9b59b6; */
		  color: #fff;
		}

		/* 所有图片容器 */
		.__Img__container .__Img__img-container {
		  position: relative;
		  margin-top: 30px;
		  width: 1005px;
		  display: flex;
		  flex-wrap: wrap;
		  transition: all .6s cubic-bezier(0.77, 0, 0.175, 1);
		}

		/* 单个图片容器 */
		.__Img__container .__Img__img-container figure {
		  width: 240px;
		  height: 140px;
		  position: absolute;
		  transition: all .6s cubic-bezier(0.77, 0, 0.175, 1);
		  transform: scale(0, 0);
		  opacity: 0;
		  overflow: hidden;
		  border-radius: 2px;
		  user-select: none;
		}

		/* 伪元素遮罩层 */
		.__Img__container .__Img__img-container figure::before {
		  display: block;
		  position: absolute;
		  width: 100%;
		  height: 100%;
		  top: 0;
		  left: 0;
		  z-index: 4;
		  background: rgba(58, 12, 5, 0.5);
		  content: ' ';
		  font-size: 0;
		  opacity: 0;
		  transition: all .3s;
		  cursor: pointer;
		}

		/* 图片 */
		.__Img__container .__Img__img-container figure img {
		  display: block;
		  width: 100%;
		  height: 100%;
		  transition: all .3s;
		}

		/* 图片标题 */
		.__Img__container .__Img__img-container figure figcaption {
		  position: absolute;
		  top: 50%;
		  left: 50%;
		  z-index: 7;
		  opacity: 0;
		  font-size: 1.5em;
		  color: rgb(255, 255, 255);
		  transform: translate(-50%, -50%);
		  transition: all .3s;
		  text-align: center;
		  cursor: pointer;
		}

		/* 悬停图片的时候标题显示 */
		.__Img__container .__Img__img-container figure:hover figcaption {
		  opacity: 1;
		}

		.__Img__container .__Img__img-container figure:hover img {
		  transform: scale(1.1, 1.1);
		}

		/* 悬停图片的时候遮罩显示 */
		.__Img__container .__Img__img-container figure:hover::before {
		  opacity: 1;
		}

		.__Img__overlay {
		  position: fixed;
		  top: 0;
		  left: 0;
		  right: 0;
		  bottom: 0;
		  background-color: rgba(0, 0, 0, .8);
		  display: flex;
		  justify-content: center;
		  align-items: center;
		  opacity: 0;
		  transition: all .3s;
		  display: none;
		}

		.__Img__overlay .__Img__overlay-prev-btn,
		.__Img__overlay .__Img__overlay-next-btn {
		  position: absolute;
		  width: 50px;
		  height: 50px;
		  border-radius: 50%;
		  border: 2px solid white;
		  text-align: center;
		  line-height: 50px;
		  color: white;
		  font-size: 2rem;
		  cursor: pointer;
		}

		.__Img__overlay .__Img__overlay-prev-btn {
		  left: 20px;
		}

		.__Img__overlay .__Img__overlay-next-btn {
		  right: 20px;
		}

		.__Img__overlay .__Img__overlay-prev-btn:active,
		.__Img__overlay .__Img__overlay-next-btn:active {
		  background: rgba(241, 241, 241, .4);
		}

		.__Img__overlay .__Img__overlay-next-btn::after {
		  content: "N";
		}

		.__Img__overlay .__Img__overlay-prev-btn::after {
		  content: "P";
		}

		.__Img__overlay img {
		  transform: scale(2, 2);
		}
	</style>
</head>
<body>
	<div id="wrap">
		<!-- <div class="__Img__container">
      		<ul class="__Img__classify">
		        <li class="__Img__classify__type-btn __Img__type-btn-active">类别1</li>
		        <li class="__Img__classify__type-btn">类别2</li>
	      	</ul>
	        <div class="__Img__img-container">
		        <figure>
		          <img src="./images/1.jpg" alt=""/>
		          <figcaption>title</figcaption>
		        </figure>
	        </div>
    	</div> -->
  	</div>
	<!-- <div class="__Img__overlay">
	    <div class="__Img__overlay-prev-btn"></div>
	    <div class="__Img__overlay-next-btn"></div>
	    <img src="images/1.jpg" alt="">
	</div> -->


<!-- data -->
<script>
	const data = [

	  {
	    type: 'JavaScript',
	    title: 'ES6快速入门',
	    alt: 'ES6快速入门',
	    src: './images/1.jpg'
	  },

	  {
	    type: 'JavaScript',
	    title: 'Javascript实现二叉树算法',
	    alt: 'Javascript实现二叉树算法',
	    src: './images/2.jpg'
	  },

	  {
	    type: 'JavaScript',
	    title: 'Canvas绘制时钟',
	    alt: 'Canvas绘制时钟',
	    src: './images/3.jpg'
	  },

	  {
	    type: 'JavaScript',
	    title: '基于websocket的火拼俄罗斯',
	    alt: '基于websocket的火拼俄罗斯',
	    src: './images/15.jpg'
	  },

	  {
	    type: '前端框架',
	    title: 'React知识点综合运用实例',
	    alt: 'React知识点综合运用实例',
	    src: './images/4.jpg'
	  },

	  {
	    type: '前端框架',
	    title: 'React组件',
	    alt: 'React组件',
	    src: './images/5.jpg'
	  },

	  {
	    type: '前端框架',
	    title: 'Vue+Webpack打造todo应用',
	    alt: 'Vue+Webpack打造todo应用',
	    src: './images/6.jpg'
	  },

	  {
	    type: '前端框架',
	    title: 'Vue.js入门基础',
	    alt: 'Vue.js入门基础',
	    src: './images/7.jpg'
	  },

	  {
	    type: '前端框架',
	    title: '使用Vue2.0实现购物车和地址选配功能',
	    alt: '使用Vue2.0实现购物车和地址选配功能',
	    src: './images/8.jpg'
	  },

	  {
	    type: 'React',
	    title: 'React知识点综合运用实例',
	    alt: 'React知识点综合运用实例',
	    src: './images/4.jpg'
	  },

	  {
	    type: 'React',
	    title: 'React组件',
	    alt: 'React组件',
	    src: './images/5.jpg'
	  },

	  {
	    type: 'Vue.js',
	    title: 'Vue+Webpack打造todo应用',
	    alt: 'Vue+Webpack打造todo应用',
	    src: './images/6.jpg'
	  },

	  {
	    type: 'Vue.js',
	    title: 'Vue.js入门基础',
	    alt: 'Vue.js入门基础',
	    src: './images/7.jpg'
	  },

	  {
	    type: 'Vue.js',
	    title: '使用Vue2.0实现购物车和地址选配功能',
	    alt: '使用Vue2.0实现购物车和地址选配功能',
	    src: './images/8.jpg'
	  }
	]
</script>
<script>
	(function (window, document){
		let canChange = true;
		let curPreviewImgIndex = 0;
		let Img = function(options){
			this._init(options);
			this._createElement();
			this._show();

			this._bind();
		}
		const methods = {
			appendChild(parent, ...children) {
				children.forEach(el => {
					parent.appendChild(el);
				});
			},
			$(selector, root = document) {
				return root.querySelector(selector);
			},
			$$(selector, root = document) {
				return root.querySelectorAll(selector);
			}
			};

		Img.prototype._init = function({data, initType, parasitifer }){
			this.types = ['全部'];   // 所有的分类
			this.all = [];    // 所有图片元素
			this.classified = {'全部': []}; // 按照类型分类后的图片
			this.curType = initType;    // 当前显示的图片分类
			this.parasitifer = methods.$(parasitifer);   // 挂载点
			this.imgContainer = null;   // 所有图片容器
			this.wrap = null;                  // 整体容器
			this.typeBtnEls = null;    // 所有分类按钮组成的数组
			this.figures = null;     // 所有当前显示图片组成的数组
			this._classify(data);
			console.log(this.classified);
		};  

		Img.prototype._classify = function(data){
			// 归类的最终效果
			/*classified: {
				"类型1": [0],
				"类型2": [1,3],
				"类型3": [2,3,4],
			}*/
			let srcs = [];
			// forEach(item,index)   默认的第一个参数是循环到的那个元素，第二个参数是这个元素的index
			// 添加分类
			data.forEach( ({ title, type, alt, src }, index) => {
				// 没有这个类  新增
				if(!this.types.includes(type)){
					this.types.push(type);
				}
				// Object.keys(this.classfied)  返回 this.classfied这个对象的所有keys组成的数组。
				if(!Object.keys(this.classified).includes(type)){
					// 新增一个   'type':[]
					this.classified[type] = [];
				}

				if(!srcs.includes(src)){
					// 图片没有生成过
					// 生成图片
					// 添加到对应的分类中
					srcs.push(src);
					let figcaption = document.createElement('figcaption');
					let figure = document.createElement('figure');
					let img = document.createElement('img');
					img.src = src;
					img.setAttribute('alt',alt);
					figcaption.innerText = title;
					methods.appendChild(figure, img, figcaption);
					this.all.push(figure);
					this.classified[type].push(this.all.length - 1);
				}else{
					// 去all中 找到对应的图片
					// 添加到对应的分类中
					// 如果s1=src  就返回s1
					this.classified[type].push(srcs.findIndex(s1 => s1 == src));
				}
			})
		};

		Img.prototype._getImgsByType = function(type){
			// array.map(function(currentValue, index, arr), thisIndex)   currentValue 当前元素的值 必须，其他可选。   对一个数组调用，遍历当前数组内所有元素，返回经过function操作后返回的值
			// 先从分类器中拿到对应type的所有图片下标数组，然后根据每个下标去all里面寻找图片
			return type === '全部' ? [...this.all] : this.classified[type].map(index => this.all[index]);
		};

		Img.prototype._createElement = function(){
			// 创建分类按钮
			let typeBtn = [];
			for(let type of this.types.values()){
				typeBtn.push(`
					<li class="__Img__classify__type-btn ${type === this.curType ? '__Img__type-btn-active' : ""}">${ type }</li>
				`);
			}
			// 整体模板
			let tamplate = `
				<ul class="__Img__classify">
					${ typeBtn.join('') }
	      		</ul>
	      		<div class="__Img__img-container">
	        	</div>
			`;
			let wrap = document.createElement('div');
			wrap.className = '__Img__container';
			wrap.innerHTML = tamplate;
			this.imgContainer = methods.$('.__Img__img-container', wrap);
			this._getImgsByType(this.curType);
			methods.appendChild(this.imgContainer, ...this._getImgsByType(this.curType));
			this.wrap = wrap;
			this.typeBtnEls = [...methods.$$('.__Img__classify__type-btn',wrap)];
			this.figures = [...methods.$$('figure',wrap)];

			// 遮罩层
			let overlay = document.createElement('div');
			overlay.className = '__Img__overlay';
			overlay.innerHTML = `
				<div class="__Img__overlay-prev-btn"></div>
				<div class="__Img__overlay-next-btn"></div>
				<img src="" alt="">
			`;
			methods.appendChild(this.wrap, overlay);
			this.overlay = overlay;
			this.previewImg = methods.$('img', overlay);
			// 设置图片的绝对定位
			this._calcPosition(this.figures);
		};
		// 找到切换前和切换后图片相同的图片的下标
		Img.prototype._diff = function(preImgs, nextImgs){
			let diffArr = [];
			// [1, 2, 3, 5, 6]
			// [3, 9, 11, 12, 14]
			// [[2, 0]]    prev的下标为2的跟next的下标为0的相同
			preImgs.forEach((src1, index1) => {
				// findIndex 根据条件(回调) 按顺序遍历数组 当回调返回true时 就返回当前遍历到的下标     同find一样，只是返回的是下标   效果同indexOf  但是indexOf没法判断NaN
				// 例如：const res = [1, 7, 6, 3, NaN].findIndex((value, index, arr) => Number.isNaN(value));      //   可以自己写一个判断函数，来获取NaN
				let index2 = nextImgs.findIndex((src2) => src1 === src2);

				if(index2 != -1)
					diffArr.push([index1,index2]);
			});
			return diffArr;
		};

		Img.prototype._bind = function(){
			methods.$('.__Img__classify',this.wrap).addEventListener('click', ({target}) => {
				// console.log(target);
				if(target.nodeName !== 'LI')	return;
				// 因为后面 图片的显示操作是有600的延迟，如果在这段延迟时间内，切换标签，会带来错误。  所以加一个判断，变化未完成，点击标签无效
				if(!canChange)	return;
				canChange = false;

				const type = target.innerText;
				const els = this._getImgsByType(type);    // 当前需要（点击后）显示分类下面的元素
				let prevImgs = this.figures.map(figure => methods.$('img', figure).src);
				let nextImgs = els.map(figure => methods.$('img',figure).src);

				const diffArr = this._diff(prevImgs, nextImgs);
				// console.log(diffArr);
				diffArr.forEach(([, i2]) => {
					// 在当前的图片集合中去找 i2 下标的图片   i2是nextImg里面需要显示的那些
					// 对遍历到的每个对象都执行函数操作 只有 每个对象操作完都返回true才会获得结果true，
					// some()是 有一个true就可以

					// this.figures.every((figure, index) => {
					// 	let src = methods.$('img', figure).src;
					// 	if(src === nextImgs[i2]){
					// 		// 区别于 stringObject.slice(start,end) 不包含end String.slice() 与 Array.slice()
					// 		// arrayObject.splice(index,howmany,item1,.....,itemX) index和howmany是必须，起始坐标和多少个，howmane=0，不删除
					// 		this.figures.splice(index, 1);
					// 		return false;
					// 	}
					// 	return true;
					// });
					// forEach 是自己写的方法  上面every是老师的方法
					this.figures.forEach((figure, index) => {
						let src = methods.$('img', figure).src;
						if(src === nextImgs[i2]){
							this.figures.splice(index, 1);
						}
					})
				});
				// 计算当前需要显示的这些图片的位置
				this._calcPosition(els);
				let needAppendEls = [];    // 需要新加入的（上一个分类没有，这个分类有）
				if(diffArr.length){   // 存在不相同的
					let nextElsIndex = diffArr.map(([, i2]) => i2);
					// els是点击后需要显示的
					els.forEach((figure, index) => {
						// nextElsIndex是不同的元素
						// 需要显示的图片  不存在于  不同的元素 这个集合中。 说明是相同的，就需要append
						if(!nextElsIndex.includes(index))
							needAppendEls.push(figure);
					});
				}else{   // 没有不相同的  els里面就都是需要新增加的
					needAppendEls = els;
				}
				this.figures.forEach(el => {
					el.style.transform = 'scale(0,0) translate(0%, 100%)';
					el.style.opacity = '0';
				})

				methods.appendChild(this.imgContainer, ...needAppendEls);
				setTimeout(() => {
					els.forEach(el => {
						el.style.transform = 'scale(1,1) translate(0,0)';
						el.style.opacity = '1';
					})
				})
				// 动画完成之后 从container里面移除元素
				setTimeout(() => {
					this.figures.forEach(figure => {
						this.imgContainer.removeChild(figure);
					});
					this.figures = els;
					canChange = true;
				}, 600);   // 动画样式transition设置的是600，

				this.typeBtnEls.forEach(btn => (btn.className = '__Img__classify__type-btn'));

				target.className = '__Img__classify__type-btn __Img__type-btn-active';
			});
			// 事件代理
			this.imgContainer.addEventListener('click', ({ target }) => {
				// 此处 addEventListener的回调函数默认传入 MouseEvent， 通过解构赋值拿到mouseEvent里面的target
				if(target.nodeName !== 'FIGURE' && target.nodeName !== 'FIGCAPTION')
					return;
				// 如果对象是figcaption即图片上的标注字 就把target换成图片，便于后面统一操作
				if(target.nodeName === 'FIGCAPTION')
					target = target.parentNode;
				const src = methods.$('img', target).src;
				curPreviewImgIndex = this.figures.findIndex(figure => src === methods.$('img',figure).src);
				this.previewImg.src = src;
				this.overlay.style.display = 'flex';   // 和block差不多
				// 异步 上面处理完成之后 再显示遮罩层
				setTimeout(() => {
					this.overlay.style.opacity = '1';
				})
			});

			this.overlay.addEventListener('click', () => {
				this.overlay.style.opacity = '0';
				setTimeout(() => {
					this.overlay.style.display = 'none';   // 仅仅设置opacity为0是看不见，但是仍然在，导致我们不能点击其他元素
				}, 300)   // overlay隐藏的动画效果时间是300
			});

			methods.$('.__Img__overlay-prev-btn', this.overlay).addEventListener('click',e => {
				e.stopPropagation();
				curPreviewImgIndex = curPreviewImgIndex === 0 ? this.figures.length - 1 : curPreviewImgIndex - 1;
				this.previewImg.src = methods.$('img', this.figures[curPreviewImgIndex]).src;
			});
			methods.$('.__Img__overlay-next-btn', this.overlay).addEventListener('click',e => {
				e.stopPropagation();
				curPreviewImgIndex = curPreviewImgIndex === this.figures.length - 1 ? 0 : curPreviewImgIndex + 1;
				this.previewImg.src = methods.$('img', this.figures[curPreviewImgIndex]).src;
			});
		};

		Img.prototype._show = function(){

			methods.appendChild(this.parasitifer, this.wrap);
			// css里面图片隐藏是采用默认transform设置为scale(0，0)，opacity=0来达到的。  直接修改transform和opacity会因为同步任务的原因，图片直接显示，没有过度动画，可以通过施加一个没有延迟的定时器去实现异步
			setTimeout(() => {
					this.figures.forEach(figure => {
					figure.style.transform = 'scale(1,1) translate(0, 0)';
					figure.style.opacity = '1';
				});
			});
		};


		// 计算每张图片的位置  top left  每个图都是绝对定位的 absolute     计算父容器高度
		Img.prototype._calcPosition = function(figures){
			figures.forEach((figure, index) => {
				figure.style.top = parseInt(index / 4) * 140 + parseInt(index / 4) * 15 + 'px';
				figure.style.left = parseInt(index % 4) * 240 + parseInt(index % 4) * 15 + 'px';
				figure.style.transform = 'scale(0, 0) translate(0, -100%)';
			});
			// 父容器背景高度
			let height = Math.ceil(figures.length / 4);
				// 间距需要减1
			this.imgContainer.style.height = height * 140 + (height - 1) * 15 + 'px';
		};
		window.$Img = Img;
	})(window, document);
</script>
<script>
	const img = new $Img({
		data,
		initType: '全部',
		parasitifer: '#wrap'
	});
</script>
</body>
</html>