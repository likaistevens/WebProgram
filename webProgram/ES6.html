<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>


<script>
    // 变量的命名
    // 全局下的变量，相当于对window下的变量。
    if (window.location.href === location.href) {
    }

    // let 声明的变量只在当前（块级）作用域内有效。 不能被重复声明。不存在变量提升
    // 块级作用域：一对花括号中的区域   {}  if(){}   for(){}  try{}catch(){}   块级作用域可以嵌套   注意：var obj = {}  这里是对象，不是块级作用域
    {
        var a = 1;
        let b = 2;
    }
    console.log(a);    // 1  对于a来说，有没有块级作用域，效果一样.都可以在外面正常访问
    console.log(b);    // error  对于b来说，只能在块级作用域内访问

    {
        let a = 1;
        {
            console.log(a);    // 1   a作用范围包括了内部的块级作用域
            let b = 2;
        }
        console.log(b);   // error   b仅仅存在于内部那个作用域
    }

    for (var i = 0; i < 3; i++) {
        console.log(i);   // 0 1 2
    }
    console.log(i);       // 3      var声明了变量之后，就一直存在，for循环结束后，他还在。
    for (var i = 0; i < 3; i++) {    // 可以继续声明i，并重新赋值
        console.log(i);   // 0 1 2
    }
    var dad = '我是爸爸';
    console.log(dad);
    var dad;
    console.log(dad);   // 依旧输出 '我是爸爸'

    let son = '我是儿子';
    let son;   // error 变量已经声明过了

    // 变量提升
    console.log(mom);    // undefined  虽然开始没有声明mom但是，默认赋值undefined。
    var mom = '我是妈妈';   //
    // 整个过程相当于
    var mom;
    console.log(mom);
    mom = '我是妈妈';

    console.log(mom);    // error 报错
    let mom = '我是妈妈';

    // 暂存死区
    var monkey = '111';
    {
        console.log(monkey);   //  111 块级作用域对于var没效果，会自动查找上面的变量
        var monkey = '222';
    }
    console.log(monkey);     // 222  块级作用域中修改了变量，生效了

    let monkey = '111';
    {
        console.log(monkey);   //  error  let直接封闭作用域，这里的变量，不能向上找了，向下又找不到
        let monkey = '222';
    }
    console.log(monkey);

    // Question： 生成十个按钮，每个点击的时候弹出1 - 10
    var i = 0;
    for (i = 1; i <= 10; i++) {
        // 一个自运行的函数 (function (i))(i)       相当于(function (i))(1)   (function (i))(2)   (function (i))(3) ...
        // 这个函数里面的i是独立的作用域，是最后（i）传进来的
        (function (i) {
            var btn = document.createElement('button');
            btn.innerText = i;
            btn.onclick = function () {
                alert(i);
            };
            document.body.appendChild(btn);
        })(i)
    }
    // 去掉自运行的函数，结果会生成1-10个按钮，但是弹出来的永远是11
    var i = 0;
    for (i = 1; i <= 10; i++) {
        var btn = document.createElement('button');
        // 这个i会遵循1-10的循环，所以生成按钮内容都是1-10
        btn.innerText = i;
        //  这里的i并不参与循环，相当于给每个按钮绑定一个事件。此时alert里面的值没确定。，每次点击按钮的时候，alert（i）就会向上去找i，此时i已经结束循环了，变成11
        btn.onclick = function () {
            alert(i);
        };
        document.body.appendChild(btn);
    }
    // 用let就和其他java等语言一样，这个i只作用于当前for循环的作用域内，不需要自运行函数
    for (let i = 1; i <= 10; i++) {
        var btn = document.createElement('button');
        btn.innerText = i;
        btn.onclick = function () {
            alert(i);
        };
        document.body.appendChild(btn);
    }

    // 常量const
    // 声明常量
    const a = 1;   // 常量在声明的时候必须被初始化
    a = 2;   // error  常量不能被修改

    // 这是一个引用类型的常量  里面的内容可以修改
    const xiaoming = {
        age: 14,
        name: 'xiaoming',
    };
    xiaoming.age = 22;    // const只会保证这个引用常量的地址不发生改变，修改里面的值不会改变地址。
    console.log(xiaoming);   // 此处age变成了22
    xiaoming = {};          // 报错

    const ARR = [];
    ARR.push(1);   // 可以改变数组中的元素。

    // Question: 解决引用类型的常量可以被修改的问题
    // Object.freeze()
    const xiaoming = {
        age: 14,
        name: 'xiaoming',
    };
    Object.freeze(xiaoming);
    xiaoming.age = 22;
    console.log(xiaoming);   // 虽然不会报错，但是没有任何修改

    // Question： ES6之前怎么声明常量
    // Object.defineProperty();
    var CST = {};
    Object.defineProperty(CST, 'BASE_NAME',{
        value: 'xiaoming',   // BASE_NAME = 'xiaoming'
        writable: false,    // 该对象，不可被修改
    });
    // 上面这样只是不能修改里面的属性。但是可以加属性   例如： CST.a = 2;   就可以加进去
    Object.seal(CST);  // 只有freeze一半的功能，不允许拓展，但是可以修改内部的值

    // SE6之前声明常量  （实现freeze效果）
    // 1.遍历属性和方法
    // 2.修改遍历到的属性和描述
    // 3.Object.seal()
    Object.defineProperty(Object, 'freezePolyfill', {
        // 相当于 Object.freezePolyfill = function(){}  这是自己定义一个函数
        value: function (obj) {
            var i;
            for(i in obj){
                // for(i in obj)  不光会遍历到obj下的属性，还会遍历到obj._proto_下的属性。  hasOwnProperty确保遍历到的只是obj下的属性
                /*
                var obj1 = {a:1 , b :2,};
                var obj2 = Object.create(obj1);   // 把obj1作为原型创建obj2，此时obj1的属性就会作为obj2._proto_ 保存
                obj2.c = 3;                       // obj2 = { c: 3, d : 4, _proto : {a : 1, b : 2,} }
                obj2.d = 4;
                for(let i in obj2){ document.body.innerHTML += (i + ': ' + obj2[i] + '<br>');    }    // 此处会遍历出所有a，b，c，d
                */
                if(obj.hasOwnProperty(i)){
                    Object.defineProperty(obj, i, {
                        writable: false,
                    });
                }
            }
            Object.seal(obj);
        }
    });
    const xiaoming = {
        age: 14,
        name: 'xiaoming',
    };
    Object.freezePolyfill(xiaoming);   // 此时  这个引用类的常量内部的属性都不能修改了


    // --------------------------解构赋值--------------------------
    // 解构赋值：是JavaScript表达式，可以将值从数组或属性从对象中提取到不同的变量中
    // 数组的解构赋值
    const arr = [1,2,3,4];
    let [a,b,c,d] = arr;          // 直接让a=1，b=2... 不用一个个的 a = arr[0],b = arr[1]...

    const arr = ['a','b',['c','d',['e','f','g']]];
    const [a,b] = arr;            // 可以获取到a,b，后面没有变量，就不会得到第三个变量，只会获取到a和b
    const [ ,b] = arr;            // 只需要b的话，就把前面的空出来。  同样获取到b
    const [ , , g] = arr;         // 此时g是一个数组，再对g进行解构赋值，继续获得数组，再解构一次
    const [ , , [ , , [ , , g]]] = arr;  // 此时可以获取到g
    // 扩展运算符  ...
    const arr1 = [1,2,3];
    const arr2 = ['a','b'];
    const arr3 = ['zz',1];
    const arr4 = [arr1,arr2,arr3];   // arr4 包含三个元素，每个元素都是数组
    const arr5 = [...arr1, ...arr2, ...arr3];  // arr5 包含7个元素 【1,2,3，'a','b'，'zz',1】

    const arr = [1,2,3,4,5,6];
    const [a, b, ...c] = arr;      // c = [3, 4, 5, 6]
    const [a, b, ...c, d] = arr;    // 报错   使用拓展运算符的变量必须是最后一个
    // 默认值
    const arr = [1, undefined, undefined];
    const [a, b, c , d] = arr;          // 此时 a=1   b，c，d都是undefined   d是多出来的，未匹配到的都会赋值为undefined
    const [a, b=2, c, d='aaa'] = arr;   // a=1,b=2,c=undefined,d='aaa'    给b和d默认值，变量是undefined的时候，就会采用默认值。   只有undefined， 取值为null的时候不会
    // 交换变量
    [a, b] = [b, a]       // 不需要中间变量，直接交换a和b
    // 接受多个 函数返回值
    function getUserInfo(id) {
        // ...ajax  执行ajax

        return [
            true,
            {
                name: 'xiaoming',
                gender: 'female',
                id: idx,
            },
            '请求成功'
        ];
    };
    const [status, data, msg] = getUserInfo(123);

    // 对象的解构赋值
    const {a,b} = {a:1, b:2};       // 等号两边都是对象结构
    const obj = {
        saber: '阿尔托莉雅',
        archer: '卫宫'
    };
    // 左边变量的值必须跟结构对象里面的key对应，不然匹配不到，返回undefined  且可以不按顺序。   数组是有序的，对象是无序的
    const {archer,saber} = obj;

    const player = {
    	nickname: '感情的戏∫我没演技∆',
    	master: '东海龙王',
    	skill: [{
    		skillName: '龙吟',
    		mp: '100',
    		time: 6000
    	},{
    		skillName: '龙卷雨击',
    		mp: '400',
    		time: 3000
    	},{
    		skillName: '龙腾',
    		mp: '900',
    		time: 60000
    	}]
    };
    const {nickname} = player;    // 直接通过key寻找value，不需要预留空格
    // 保持左边跟右边形式一样。直接提取skill里的第一项，{skillName: '龙吟',mp: '100',time: 6000}    此时skill是没有被提取，没有值。
    const {skill: [skill1] } = player;    // skill1 是对数组解构，得到的变量，这个变量名只要合法就可以
    const {skill: [skill1,{skillName}] } = player;  // 再对skill1进行对象解构赋值，提取skillName
    const {skill: [skill1,{skillName}, {skillName}] } = player;    // 想要提取 龙腾 这个名字。   采取这种办法会报错，skillName重复使用
    const {skill: [skill1,{skillName}, {skillName: skillName3}] } = player;    // 可以在key后面 冒号再加一个自定变量名。  会自动把提取到的value放入变量中。

    const obj = {
    	saber: '阿尔托利亚',
    	archer: '卫宫',
    	lancer: '瑟坦达'
    };
    const {archer, ...oth} = obj;    // 配合扩展运算符    其他两个没有匹配的被作为一个对象放入oth变量中
    const obj = {
        saber: '阿尔托利亚',
        ...{                        // 对象扩展，相当于obj里有三个值
            archer: '卫宫',
            lancer: '瑟坦达'
        },
    };
    // 等价于
    const obj1 = {
        archer: '卫宫',
        lancer: '瑟坦达'
    };
    const obj = {
        saber: '阿尔托利亚',
        ... obj1,
    };
    // 对已声明的变量进行对象解构赋值
    let age ;
    const obj = {
        name: 'xiaoming',
        age: 22,
    };
    {age} = obj;   // 这样会报错，编译器把前面的大括号当作了块级作用域
    ({age} = obj);   // 外面加一个小括号就可以了
    // 默认值
    let girlfriend = {
    	name: undefined,
    	age: 22,
    };
    let { name = 'xiaohong', age = 24, hobby = ['学习'] } = girlfriend;   // 匹配不到或者undefined就会采用默认值。 结果  name = 'xiaohong',age = 22，hobby = ['学习']

    const { name, hobby: [ hobby1 ], hobby } = {    // 如果只写了hobby: [ hobby1 ]，此时拿不到hobby这个变量。  所以在后面再加一个hobby就可以拿到hobby了
    	name: '小红',
    	hobby: ['学习']
    };
    // 使用对象传入乱序的函数参数
    // 直接对传入的对象进行解构赋值，然后在传入函数    不需要关注传入对象的值的顺序
    function Ajax({
        url,
        data,
        type = 'get'    // 默认值为'get'
                  }) {
        // 传统的，如果想表达传入的 option有type就用传入的type，没有就采用'get'就需要采用以下方法判断
        // var type = option.type || 'get';
    }
    Ajax({
        data: {
            a: 1,
        },
        url: '/getInfo',
    })
    // 获取多个函数返回值
    function getUserInfo(uid) {
    	// ...ajax
    	return {
    		status: true,
    		data: {
    			name: '小红'
    		},
    		msg: '请求成功'
    	};
    };
    const { status, data, msg: message } = getUserInfo(123);

    // 字符串的解构赋值
    // 跟数组一样，只是把字符串拆成一个个字符，  注意：空格也算一个字符
    const str = 'I am the bone of my sword'; // 我是剑骨头
    const [ a, b ,c, ...oth ] = str;     // a='I' b=' ' c='a' oth = ['m',' ','t'....]      剩余没匹配的。作为一个数组返回
    // 下面这三个 都是一样的内容，将整个字符串分割成一个个字符
    const [ ...spStr1 ] = str;
    const spStr2 = str.split('');
    const spStr3 = [ ...str ];
    // 提取字符串的属性和方法
    const {length, split} = str;    // length = 25     split  = function(){}   获取到字符串的长度，已经他的分割方法
    split.call('1,2,3',',');        // 使用call调用提取到的方法

    // 数值与布尔值的解构赋值
    const {valueOf} = 1;        // 提取数值的valueOf方法    实际实现把1转化成包装类，然后包装类对象有方法可以被提取
    const {valueOf : vo} = 1;   // 将提取到的方法放到 vo这个变量中
    const {toString: ts} = false;  // 提取布尔值的toString方法到变量ts中


    // 函数参数的解构赋值
    function swap([x, y]) {   // 交换数组中的元素
    	return [y, x];
    };

    function Computer({
          cpu,
          memory,
          software = ['ie6'],
          OS = 'windows 3.5'
    }) {
        console.log(cpu);
        console.log(memory);
        console.log(software);
        console.log(OS);
    };

    new Computer({
        memory: '128G',
        cpu: '80286',
        OS: 'win',
    });


    // 模版字符串
    // ` `    数字1 旁边"～"键打出的反单引号   表明是模版字符串
    const xiaoming = {
        name: 'xiaoming',
        age: 14,
        say1: function () {
            // 常规 用 + 拼接
            console.log('I am ' + this.name + ', I am ' + this.age + ' years old');
        },
        say2: function () {
            // 用 ` ` 配合 + 效果一样
            console.log(`I am ` + this.name + `, I am ` + this.age + ` years old`);
            // 利用模版字符串  里面的变量用 ${} 包裹，直接放到模版字符串里面代替内容
            console.log(`I am ${this.name}, I am ${this.age}years old`);
            // 模版字符串里面嵌套模版字符串
            console.log(`I am ${ `Mr.${this.name} `}, I am ${this.age}years old`);
            // 正常的字符串方法也可以对其中的字符串使用
            console.log(`I am ${ `Mr.${this.name.toUpperCase()} `}, I am ${this.age}years old`);
        },
    }
    xiaoming.say2();


    const getImoocCourseList = function() {
        // ajax
        return {
            status: true,
            msg: '获取成功',
            data: [{
                id: 1,
                title: 'Vue 入门',
                date: 'xxxx-01-09'
            }, {
                id: 2,
                title: 'ES6 入门',
                date: 'xxxx-01-10'
            }, {
                id: 3,
                title: 'React入门',
                date: 'xxxx-01-11'
            }]
        }
    };

    const {data: listData, status, msg} = getImoocCourseList();
    function foo(val) {
        return val.replace('xxxx','2020');
    }
    if(status){
        let arr = [];
        // forEach 回调函数拿到的是遍历的每个对象  对每个对象都进行解构
        listData.forEach(function ({date,title}) {
            /*arr.push(
                '<li>\
                    <span>'+ title +'</span>\
                    <span>'+ date +'</span>\
                </li>'
            )*/

            arr.push(
                `<li>
                    <span>${ `课程名称：${ title }`}</span>
                    <span>${ foo(date) }</span>
                </li>`
            )
        });

        let ul = document.createElement('ul');
        ul.innerHTML = arr.join('');
        document.body.appendChild(ul);
    }else{
        alert(msg);
    }

    // padStart   padEnd
    {
        let str = 'i';
        let str1 = str.padStart(6,'mooc');  // 'moocmi'     在前面 补全到六位  传入的字符串长度不够 会自动重复 裁剪
        let str2 = str.padEnd(6,'mooc');    // 'imoocm'     在后面 补全六位
    }
    // repeat
    {
        console.log('i'.repeat(10));    // iiiiiiiiii
        console.log('i'.repeat(2.33));  // iii       小数会被向上取整
        console.log('i'.repeat(-0.88));  // ' '     不能传入小于-1的负数  大于-1的负数 会被取为0

        // 自己写一个repeat方法
        function repeat(str, num) {
            return new Array(num + 1).join(str);
        }
        console.log('s',3);             // sss
    }

    // startsWith endsWith
    {
        const str = 'A promise is a promise';

        console.log(str.startsWith('B'));     // false
        console.log(str.startsWith('A pro')); // true

        console.log(str.endsWith('promise')); // true
        console.log(str.endsWith('A'));       // false
    }

    // includes
    {
        const str = 'A promise is a promise';

        // 不存在 indexOf 会返回 -1
        if (str.indexOf('promise') !== -1) {
            console.log('存在1');
        }
        // 用 按位取反替代判断    ~x = -(x + 1)   相当于把数字 + 1 然后取负数
        // 返回 -1 表示不存在，按位取反得到 0 相当于 false   其他数值都相当于true
        if (~str.indexOf('promise')) {
            console.log('存在1');
        }

        if (str.includes('a promise')) {
            console.log('存在2');
        }
    }

    // 遍历字符串
    // for循环
    let str = 'PROMISE';
    for(var i = 0, len = str.length; i < len; i++){
        console.log(str[i]);
        console.log(str.charAt(i));
    }
    // 转成数组后遍历
        // 两种分割方法 转成数组
    var oStr1 = Array.prototype.slice.call(str);    // ["P", "R", "O", "M", "I", "S", "E"]
    var oStr2 = str.split('');                      // ["P", "R", "O", "M", "I", "S", "E"]
        // 拓展运算符  转成数组    ...object 相当于把对象的每个属性都给拆开 并列存放   此处字符串 也相当于把字符串拆开 并列存放
    const oStr3 = [...str];                         // ["P", "R", "O", "M", "I", "S", "E"]
        // 赋值给字符串 字符串解构赋值 得到数组
    const [...oStr] = str;
    console.log(oStr);                              // ["P", "R", "O", "M", "I", "S", "E"]
    // forEach循环遍历数组   回调函数里面是遍历的每个元素
    oStr.forEach(function (word) {
        console.log(word);
    });
    // 有时候遍历是为了操作字符串
    // 对全是英文的字符串中的大写字符加密 A -> 100  B -> 99。。。
    const map = {A: '100', B: '99', C: '98', D: '97', E: '96', F: '95', G: '94', H: '93', I: '92', J: '91', K: '90', L: '89', M: '88', N: '87', O: '86', P: '85', Q: '84', R: '83', S: '82', T: '81', U: '80', V: '79',W: '78',X: '77',Y: '76', Z: '75'};
    const words = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

    oStr.forEach(function(word, index) {
        // 判断是不是大写
        if (words.includes(word))
            oStr[index] = map[word];
    });
    // 将包含数字的数组 拼成字符串
    console.log(oStr.join(''));

    // for-of 遍历
    for(let word of str){
        console.log(word);
    }
    // for-of 循环可以直接操作字符串
    let newStr = '';
    for(let word of str){
        if(word.includes(word))
            newStr += map[word];
    }
    console.log(newStr);

    // unicode表示法  码点
    // 正常js只能识别 0000-ffff之间的unicode    ES6中可以通过大括号扩起来 让浏览器去解析超出范围的unicode
    // \u1f436    -->   '\u{1f436}' "🐶"   记住要带引号

    // codePointAt 获取字符串中对应字符的一个码点
    "🐶".codePointAt(0);                // 128054
    "🐶".codePointAt(0).toString(16);   // "1f436"  转化成16进制

    // 正则表达式
    const regexp1 = /^a/g;
    const regexp2 = new RegExp('^a', 'g');
    const regexp3 = new RegExp(/^a/g);
    // 上面三个正则表达式 是一模一样的
    const regexp4 = new RegExp(/a/g);    // 不需要a顶头
    const regexp5 = new RegExp(/a/);     // 不需要a顶头 且不需要全局匹配

    console.log('aabbcc'.match(regexp1));   // a
    console.log('babbcc'.match(regexp1));   // null
    console.log('aabbccaabbaa'.match(regexp4));   // 匹配到6个 "a"
    console.log('aabbccaabbaa'.match(regexp5));   // 只会匹配第一个 "a"

    // 构造函数的变化
    // ES6 中   构造函数前面正则表达式写了修饰符，后面还加入一个修饰符的参数，不会报错，前面的会被后面覆盖    ES6之前，这样做会报错。
    const regexp5 = new RegExp(/a/giuy, 'ig');

    // uy修饰符
    // u.  unicode
    console.log(/^\ud83d/.test('\ud83d\udc36'));      // true   能在'\ud83d\udc36' 中匹配到 /^\ud83d/   因为匹配的时候是把这两个unicode当作字符串去处理
    // 但是实际上"\ud83d" = "�"    而"\ud83d\udc36" = "🐶"
    console.log(/^\ud83d/u.test('\ud83d\udc36'));     // false  将两个unicode作为unicode去处理  匹配不到

    // y 粘连修饰符   sticky
    const r1 = /imooc/g;   // 不用管粘不粘连 都可以匹配
    const r2 = /imooc/y;   // 相当于全局 但是 匹配到第一个之后 紧接的下面的也必须匹配
    const str = 'imoocimooc-imooc';
    // exec不会全局匹配，不管有没有g。   都只匹配第一个，但是执行一次会把 lastIndex放到上一次匹配的末尾。 因此可以反复调用，遍历
    console.log(r1.exec(str));   // imooc   index = 0
    console.log(r1.exec(str));   // imooc   index = 5
    console.log(r1.exec(str));   // imooc   index = 11
    console.log(r1.exec(str));   // null

    console.log('-----------------');

    console.log(r2.exec(str));   // imooc   index = 0
    console.log(r2.exec(str));   // imooc   index = 5
    console.log(r2.exec(str));   // null      第三个 imooc和第二个之间有个 -   没有粘连 所以不能匹配到第三个


    // 数值 扩展
    // 新的进制
    // 0o 或者 0O    octonary
    // 0b 或者 0B    binary
    console.log(0o16);    // 14
    console.log(0b1111);  // 15
    // 新的方法与安全数
    // Number.parseInt Number.parseFloat
    // ES6之前 挂在window上   不过以下两种写法还是可以用
    console.log(window.parseInt('1.23'));    // 1    可以传入字符串 转为整数 也可以穿入 小数转为整数
    console.log(parseFloat('1.23'));         // 1.23
    // ES6之后 挂载在 Number上
    console.log(Number.parseInt(1.23));   // 1
    console.log(Number.parseFloat(1.23)); // 1.23

    // Number.isNaN Number.isFinite
    // isNaN
    console.log(Number.isNaN(NaN));    // true
    console.log(Number.isNaN(-NaN));   // true
    console.log(Number.isNaN(1));      // false
    console.log(Number.isNaN('1'));    // false
    console.log(Number.isNaN(true));   // false
    // 自己写一个 isNaN    NaN 有个特性   NaN == NaN  返回false
    function isNaN(value) {
    	return value !== value;
    }
    // isFinite   判断是否有限   字符串 无限 结果为无限的计算式  NaN  boolean  都是无限的，返回false
    console.log(Number.isFinite(Infinity));  // false
    console.log(Number.isFinite(2 / 0));     // false
    console.log(Number.isFinite(2 / 4));     // true
    console.log(Number.isFinite(1234));      // true
    console.log(Number.isFinite('1234'));    // false
    console.log(Number.isFinite(true));      // false
    console.log(Number.isFinite(NaN));       // false

    // Number.MAX_SAFE_INTEGER Number.MIN_SAFE_INTEGER
    // 判断一个数是否是安全整数  即是否超过了整数范围  整数范围是  - (2^53 - 1)  到  2^53 - 1
    Number.isSafeInteger();
    console.log(Number.MAX_SAFE_INTEGER);   // 2^53 - 1
    console.log(Number.MIN_SAFE_INTEGER);   // - (2^53 - 1)
    console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER - 1));  // true
    console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1));  // false  比最大安全数还大 1
    // 幂运算
    let a = 2 ** 10;         // 1024
    let a = 2 ** 10 ** 0;    // 2      从右往左计算
    let a = (2 ** 10) ** 0;  // 1


    // 函数的扩展
    // 函数参数默认值
    function add(a, b = 999, c = 1 + a) {       // 后一个参数默认值可以是前面参数的表达式
        // 没有默认值 需要  b = b || 999;
        console.log(a,b,c);
    }
    add(2);     // 2 999 3     如果只传入一个参数，其他参数就采用默认值
    add(2,3);   // 2 3 3      传入两个，默认是前两个
    add(2,undefined,10)    // add2 999 10   如果是中间一个参数不需要，需要用undefined占位，不能用空格占位
    // 配合解构
    // function People({name, age = 38}) {}    //   如果是这样 不穿参数  会报错  name没有定义
    function People({name, age = 38} = {}) {   // {name, age = 38} 这整个对象 是函数的一个参数，  {}  是这个参数的默认值。    age = 38 是这个参数对象默认属性
        console.log(name,age);
    }
    People();    // undefined 38       对象默认设置为{}  即参数对象默认的所有参数都是 undefined  如果有参数，就使用传入的参数
    function People({name, age = 38} = { name : 1}) {   // 解构赋值，让参数对象 的name属性 默认为 1
        console.log(name,age);
    }
    People();   // 1 38
    People(3);  // 3  38

    // 剩余参数 ...
    function sum() {
        console.log(arguments);   // arguments 是所有函数都有的一个类数组对象
        console.log(arguments instanceof Array);   // false    它不是一个数组
        let args = Array.prototype.slice.call(arguments);   // 把 类数组对象转化成数组   args 包含 arguments所有的属性内容  含有数组的方法
        // let [...args] = arguments;    // 解构赋值， 数组里面有一个变量 args , ...args 表明用args装所有的内容，   [b, ...a] = [1,2,3,4]   b = 1, a = [2,3,4]
        // let args = [...arguments];    // ...arguments 相当于 把arguments的所有内容 暴露出来 放到一个数组。      [...a, ...b]  把 a b合成到一个数组
        // 这三个都可以把 类数组转化为数组
    }
    // 还可以直接在函数传参的时候处理   此处  是剩余操作符   扩展运算符 是做展开   剩余操作符 是做聚合
    function sum(...args) {
    }

    function op(type, ...nums) {    // 包含 剩余操作符的变量必须在最后
        console.log(type);
        console.log(nums);
        let sum = 0;
        if(type === 'sum'){
            for(let i of nums){
                sum += i;
            }
        }
        return sum;
    }
    op('sum',1,2,3,4,5);
    // 另一种方法实现 加法
    function sum(...nums) {
        // reduce是一个累加器    第一个参数，传入回调函数，回调函数至少两个参数，第一个是 累加初始值，第二个是当前值。    reduce的第二个参数可选，是初始值（a）的起始值
        return nums.reduce(function (a,b) {
            return a + b;      // 0 + 1 = 1    1 + 2 = 3   3 + 3 = 6    6 + 4 = 10
        },0);
    };
    console.log(sum(1,2,3,4));

    // 箭头函数
    const add1 = (a,b) => a + b;
    const add2 = function (a,b) {
        return a + b;
    }
    // 上述 add1 和 add2 等价。
    const add1 = (a,b) => {      // 有多行执行语句，就把函数体包起来
        a += 1;
        return a + b;
    }
    const add2 = function (a,b) {
        a += 1;
        return a + b;
    }
    // 上述 两个一样

    // 执行函数 有返回值  但我们自己的最终函数不希望有返回值。
    const pop = arr => arr.pop();     // 数组最后一个元素出队  并返回这个元素  此时 pop 即为最后一个元素
    const pop = arr => {              // 只有一个参数 不需要括号
        arr.pop();                    // 分行写，就不会有返回值了，此时  pop 为 undefined
    }
    const pop = arr => void arr.pop();   // 加一个 void 也不会有返回值  此时  pop 为 undefined
    // 与普通函数的区别  没有 arguments
    const log = () => {
        console.log(arguments);     // 报错   箭头函数没有 arguments
    }
    const log = (...args) => {      // 需要用 剩余参数 接受 传入的参数
        console.log(args);
    }
    // 与普通函数的区别  this指向
    const xiaoming = {
        name: 'xiaoming',
        say1: function () {
            console.log(this);    // 输出 xiaoming 这个对象
        },
        say2: () => {
            console.log(this);     // 输出 window   箭头函数没有自己的this， 他是和当前对象并列，他的this指向他所属对象的this， xiaoming这个对象属于window下。
        },
    }

    const xiaoming = {
        name: 'xiaoming',
        age: null,
        getAge1: function(){
          // ...  Ajax
            setTimeout(function(){
                console.log(this);   // window       在setTimeOut这个闭包中 拿不到外面 对象下的this 属性
            },1000);
        },
        getAge2: function(){
            let _this = this;
            // ...  Ajax
            setTimeout(function(){
                console.log(_this);   // xiaoming     可以在外面保存this，然后拿到里面的闭包中使用
                _this.age = 14;
            },1000);
        },
        getAge3: function(){
            // ...  Ajax
            setTimeout(() => {
                console.log(this);   // xiaoming     对于箭头函数，他没有自己的this，他的this就是所处环境的this，此处的环境是xiaoming这个对象下，所以，此处箭头函数可以用this拿到这个对象
                this.age = 14;
            },1000);
        },
    };


    // 对象的扩展
    // 传统表示方法
    const getUserInfo = (id = 1) => {
        // Ajax 。。。
        const name = 'xiaoming';
        const age = 10;
        return {
            name: name,
            age: age,
            say: function () {
                console.log(this.age + this.name);
            }
        };
    };
    const xiaoming = getUserInfo();
    // ES6中的简洁表示法
    const getUserInfo = (id = 1) => {
        // Ajax 。。。
        const name = 'xiaoming';
        const age = 10;
        return {
            name,           // 对象的属性 直接放属性名就可以自动匹配
            age,
            say() {         // 对象的方法  直接 方法名 + （） + { 函数体 }
                console.log(this.age + this.name);
            }
        };
    };
    const xiaoming = getUserInfo();

    // 属性名表达式
    const obj = {
        a: 1,                   // obj.a     obj['a']
        $abc: 2,
        // FDGJ$%#@%&**&^: 3,    // 这个属性名是不符合规范的属性名，会报错。   且无法通过 点 的方式获取。
        'FDGJ$%#@%&**&^': 3,     // 非法的属性名，可以用引号扩起来  但是调用的时候 也要用[] 来调用    obj['FDGJ$%#@%&**&^']
    };
    // ES6 中 属性名可以是简单的表达式
    const key = 'age';
    const xiaoming = {
        name: 'xiaoming',
        [key]: 14,                   // 中括号中放一个表达式
        ['a' + 'ge' + 123]: 14,   // 中括号中放一个表达式
        age: 14,
        [`${key}123`]: 14,        // 也可以放模版字符串
    }
    // 对象 与扩展运算符
    const obj1 = {
        a: 1,
        b: 2,
        d: {
            aa: 1,
            bb: 2,
        }
    };
    const obj2 = {
        c: 3,
        a: 9
    };
    const copyObj1 = { ...obj1 };    // 复制了 obj1    但是注意，这个复制是浅拷贝
    console.log(copyObj1.d.aa);
    copyObj1.d.aa = 999;             // 999  对复制的对象 改变属性值
    console.log(copyObj1.d.aa);      //
    console.log(obj1.d.aa);          // 999  发现原对象的属性 也发生了改变

    // 合并对象
    const newObj = {
        ...obj1,
        ...obj2,
    }
    console.log(newObj);
    /*
    newObj = {
        a: 9,        // 相同的属性  会取最后出现的那个对象
        b: 2,        // 其他属性按顺序合并
        d: {
            aa: 1,
            bb: 2,
        }
        c: 3,
    }
    */
    newObj.d.aa = 22;
    console.log(obj1);    // 发现obj1 的属性被改变了
    // 所以 注意：   扩展运算符 对 对象的合并 拷贝都是浅拷贝，会改变原对象

    // 对象的新方法
    Object.is()  // 相当于  ===   但是  === 更为严格
    // 区别
    console.log(Object.is(+0,-0));     // false
    console.log(+0 === -0);            // true
    console.log(Object.is(NaN,NaN));   // true
    console.log(NaN === NaN);          // false
    Object.assign();
    const obj = Object.assign({a: 1},{b: 2}, {c: 3}, {d: 4, e: 5});
    console.log(obj);   //    {a: 1, b: 2, c: 3, d: 4, e: 5}      把函数里面穿入的里面所有参数合并   相当于  {...obj1, ...obj2,}   同样 都是浅拷贝

    const obj = {"a" : 1, "b": 2, "c": 3};
    Object.keys(obj);       // 所有的key  放在一个 列表里 []          ["a","b","c"]
    Object.values(obj);     // 所有的value  放在一个 列表里 []        [1,2,3]
    Object.entries(obj);    // 所有的键值对  放在一个 列表里 []        [["a": 1], ["b":2], ["c": 3]]

    for(let e of Object.entries(obj)){     // 不需要像  for in   判断 hasOwnProperty
        console.log(e);        //  ["a": 1]      ["b":2]        ["c": 3]
    }
    for(let [k, v] of Object.entries(obj)){
        console.log(k, v);    //  a 1   b 2   c 3
    }
    // Object.setPrototypeOf     修改对象的原型
    const obj1 = {
        a: 1,
    };
    const obj2 = {
        b: 2,
    };
    const obj = Object.create(obj1);   // 第一个参数是需要修改原型的对象  第二个是新的原型
    console.log(obj.__proto__);        // {a: 1}
    Object.setPrototypeOf(obj, obj2);
    console.log(obj.__proto__);        // {b: 2}
    // Object.getPrototypeOf()  获取原型  跟 ._proto_ 结果一样     查看 修改原型 最好使用setPrototypeOf 和 getPrototypeOf
    console.log(obj.__proto__ === Object.getPrototypeOf(obj));    // true
    // super         指代原型对象     函数必须采用 ES6简写的方式 才可以
    const obj3 = {name: 'xiaoming'};
    const cObj = {
        say() {                                      // say: function{  }    和   say: () => {  }   都不可以使用super
            console.log(`My name is ${super.name}`);
        }
    }
    Object.setPrototypeOf(cObj, obj3);
    cObj.say();               // My name is xiaoming

    // 数组扩展  扩展运算符
    function foo(a,b,c) {
        console.log(a,b,c);
    }
    foo(...[a,b,c]);     // 扩展运算符 把数组里的元素释放

    const user = ['小明', 14, ['吃饭', '打游戏'], '我没有女朋友'];
    function say(name, age, hobby, desc) {
    	console.log(`我叫${ name }, 我今年${ age } 岁, 我喜欢${ hobby.join('和') }, ${ desc }`);
    }
    say(user[0], user[1], user[2], user[3]);     // 原始方法，一个个传参数
    say(...user);                                // 使用扩展运算符，直接释放数组里的内容
    //  任何函数都有call和apply， call后面一个个传参数，apply第二个参数是数组用于传参数  不改变指向，第一个参数就写null
    say.apply(null, user);        // 效果一样   call apply改变函数 this的指向，也可以用于传参数
    // 再举个例子
    const arr = [1, 2, 233, 3, 4, 5];
    console.log(Math.max(...arr));             // 233
    console.log(Math.max.apply(null, arr));    // 233

    const arr1 = [1, 2, 3, 4];
    const arr2 = [4, 2, 2, 1];
    const arr3 = [2.2, '123', false];

    const cArr1 = [1, 2, 3, ...arr3];    // [1, 2, 3, 2.2, "123", false]   数组与已有元素合并  扩展运算符释放数组内的元素
    // 数组赋值  两种方法 复制数组
    const cArr2 = [...arr1];             // [1, 2, 3, 4]
    const [...cArr3] = arr3;             // [2.2, "123", false]
    // 数组合并  扩展运算符释放数组内的元素
    const cArr4 = [...arr1, ...arr2, ...arr3];   // [1, 2, 3, 4, 4, 2, 2, 1, 2.2, "123", false]

    // 函数生成器 function* g(){}  或者 function *g() {} 都可以
    // 每次对函数调用 next() 都会执行到下一个next暂停，并返回yield后面的内容，外加一个done属性，函数没有return之前done为false，return之后，done就是true，返回值为undefined
    function *g() {
        console.log("第一次yield");
        yield 'hello~';
        console.log("第二次yield");
        yield 'world~';
        console.log("yield完了，要return了");
        return 'Bye~';
    };
    let fun = g();
    console.log(fun.next());   // 第一次yield  done: false  value: "hello~"
    console.log(fun.next());   // 第二次yield  done: false   value: "world~"
    console.log(fun.next());   // yield完了，要return了  done: true  value: "Bye~"
    console.log(fun.next());   // done: true  value: undefined

    const arr = [...g()];     // ["hello~", "world~"]

    let set = new Set([1, 2, 2, 3]);    // Set里面的元素不能重复
    console.log([...set]);             // [1,2,3]   对Set运用扩展运算符 变成数组。      达到去重的目的


    // Array.from()   把类数组对象 ArrayLike 或者Iterable对象转化成一个Array
    const obj = {   // 这种类数组的属性名key 必须为数值型，或者字符串型的数字
        0: 1,
        1: '22',
        2: false,
        length: 2    // 规定转化数组的长度   [1,'22']  长度尽为2
    };
    console.log(Array.from(obj));   //  [1,'22']  长度尽为2
    console.log(Array.from(obj, item => item * 2));  // [2, 44]  还可以传入一个回调函数 对每个元素进行操作  字符串型的数值会被运算符自动转化成数值

    // ES6之前 三种方法 将类数组对象转化成数组的方法
    Array.prototype.slice.call(obj);    // [1, "22"]
    [].slice.call(obj);                 // [1, "22"]
    // [...]     // 不适用于这个 obj    可以参照上面 arguments 的处理

    // Array.of    把传入的参数合成数组
    console.log(Array.of(1, 2, '123', false));    // [1, 2, "123", false]

    // Array#fill   填充数组
    let arr = new Array(10);                 // [empty x 10]
    let arr = new Array(10).fill(0);         // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    console.log([1, 2, 3].fill(0));          // [0,0,0]   数组里已经有元素 会覆盖填充
    let arr = new Array(10).fill(0, 0, 3);   // [0, 0, 0, empty × 7]      fill(a, b, c)   传入三个参数  是从第b个到第c个（不包括c），用a填充   下标从0开始计数

    // Array.includes     是否包含元素
    var arr = [1, 2, 3, 4];
    console.log(arr.includes(1));    // true
    console.log(arr.includes(55));   // false

    // keys
    const arr = [1, 2, 3, 444];
    console.log(arr.keys());         // Array Iterator {}    输出的是一个迭代器借口 并不会展示出来key()内容
    for (let i of arr.keys()) {      // for-of遍历迭代器
    	console.log(i);              // 0 1 2 3  循环输出数组的下标
    }

    // values
    for (let v of arr.values()) {
    	console.log(v);             // 1 2 3 44   循环输出数组的值
    }

    // entries
    for (let [i, v] of arr.entries()) {    // entries() 里面是   [0,1] [1,2]  [2,3]  [3,44]   用解构赋值 获取里面的值
    	console.log(i, v);           // 0 1     1 2    2 3     3 444
    }

    // find 根据条件(回调) 按顺序遍历数组 当回调返回true时 就返回当前遍历到的值    只会返回第一个符合条件的值
    const res = [1, 7 ,6 ,3 ,8].find(function (value, index, arr) {     // 回调函数默认拿到三个参数
        console.log('value',value);
        console.log('index',index);
        console.log('arr',arr);
        return value %2 === 0;       // 返回第一个value
    });
    console.log(res);   // 6
    // 写成箭头函数
    const res = [1, 7, 6, 3, 8].find((value, index, arr) => value % 2 === 0);
    console.log(res);
    // findIndex 根据条件(回调) 按顺序遍历数组 当回调返回true时 就返回当前遍历到的下标     同find一样，只是返回的是下标   效果同indexOf  但是indexOf没法判断NaN
    const res = [1, 7, 6, 3, NaN].findIndex((value, index, arr) => Number.isNaN(value));      //   可以自己写一个判断函数，来获取NaN
    console.log(res);



    // ----------------------------------Promise----------------------------------
    // 传统异步方法  回调函数
    function f(cb) {
        setTimeout(function () {
            cb && cb();    // cb是回调函数 存在就调用
        },1000);
    }
    f(function () {
        console.log(1);
        f(function () {
            console.log(2);
        });
    });

    // promise
    function f() {
        return new Promise(resolve => {
            setTimeout(function () {
                resolve();
            },1000);
        })
    }
    f()
        .then(function () {
            console.log(1);
            return f();
        })
        .then(function () {
            console.log(2);
            return f();
        })

    /*<style>
		#el{
			width: 100px;
			background: green;
			transition: all 1s;
			color: white;
			line-height: 100px;
			text-align: center;
			font-size: 40px;
		}
	</style>
	<div id="el">O</div>
	<button id="btn">start</button>*/
    // function moveTo(el, x, y, cb){
    // 	el.style.transform = `translate(${x}px, ${y}px)`;
    // 	setTimeout(function(){
    // 		cb && cb();
    // 	},1000);
    // }

    // let el = document.querySelector('div');
    // document.querySelector('button').addEventListener('click', e => {
    // 	moveTo(el, 100, 100, function(){
    // 		moveTo(el, 200, 200, function(){
    // 			moveTo(el, 100, 300, function(){
    // 				moveTo(el, 130, 20, function(){
    // 					moveTo(el, 0, 0, function(){
    // 						console.log('移动结束！');
    // 					})
    // 				})
    // 			})
    // 		})
    // 	})
    // })

    function moveTo(el, x, y){
        // 此处resolve 和下面计时器里的resolve是可以自定义的函数名，习惯性用resolve
        return new Promise(resolve => {
            el.style.transform = `translate(${x}px, ${y}px)`;
            setTimeout(function(){
                resolve();
            },1000);
        })
    }
    let el = document.querySelector('div');
    document.querySelector('button').addEventListener('click', e => moveTo(el, 100, 200)
        .then(function(){
            console.log('第一次移动');
            return moveTo(el, 100, 100);
        })
        .then(function(){
            console.log('第二次移动');
            return moveTo(el, 200, 200);
        })
        .then(function(){
            console.log('第三次移动');
            return moveTo(el, 100, 300);
        })
        .then(function(){
            console.log('第四次移动');
            return moveTo(el, 130, 20);
        })
        .then(function(){
            console.log('第五次移动');
            return moveTo(el, 0, 0);
        })
    )

    // 信任问题
    // 回调函数来自 第三方的某个库
    function method(cb) {
        // 未按所想的预期执行回调
        setTimeout(function() {
            cb && cb();  // 执行了一次回调
            cb && cb();  // 因为某种原因，又执行了一次
        }, 1000);
    }

    // promise一但被确定为成功或者失败 就不能再被更改
    function method() {
        return new Promise(resolve => {
            setTimeout(function() {
                resolve();  // 成功执行  之后就不会再执行resolve
                resolve();  // 上面一个成功了 这个不会再执行
            }, 1000);
        });
    }

    // 控制反转
    function method(cb){
        setTimeout((function){
            cb && cb.call({a: 1, b:2});      // 回调的时候可能有额外操作，但是不是我们想要的
        },1000);
    }
    function method(cb){
        return new Promise(resolve => {
            setTimeout(() => {
                resolve;   // 调用的resolve全为自己书写。
            })
        })
    }

    // 错误的处理
    // 成功与错误 的处理都是异步的  所以 try catch没有用
    // 方法一  then(resolve , reject)     reject为失败时的回调函数
    function f(val){
        // 这里参数的名字自定  只是习惯性这么取名
        return new Promise((resolve, reject) => {
            if(val){
                // 但是只能传递一个参数 第二个参数是拿不到的
                resolve({name: 'xiaoming'});
            }else{
                // 可以传入参数
                reject('404');
            }
        }
    }
    f(true)
        // 在then中传入两个函数 分别作为 resolve和reject
        .then(data => {
            // 只能接受一个参数
            console.log(data);
            // 可以接收参数
        }, e =>{
            console.log(e);
        })

    // 方法二  catch捕获
    f(true)
        .then(data => {
            console.log(data);
            return f(false);
        })
        .then( () => {
            // 上面 return回来 f(false) 此处的then必须调用reject函数，但是此处没有传reject函数，所以永远不会被执行
            console.log('此处是成功的处理，永远不会输出。')
        })
        .then(() => {

        },e => {
            console.log('e');     //   404
            console.log('这里有对失败的处理，则函数会执行，然后停止，不会执行下面的catch')
        })
        .catch(e => {
            console.log(e);    // 如果没有上面那个对失败的处理，就会执行到catch然后停止
            // return f(true);    // 可以继续返回
        })
    // ES6中 catch有个bug无法解决。  就是如果catch{ return f(false)} 即catch执行操作中继续返回一个决议失败的对象，这个错误又需要一个catch去捕获，如此就会有个错误循环

    // finally   不论成功还是失败 都会执行
    f(true)
        .then(data => {
            console.log(data);
            return f(false);
        })
        .catch(e => {
            console.log(e);
            return f(true);
            // return f(false);   // 哪怕是返回错误处理  依旧会执行finally，但是会报错，错误没有处理
        })
        .finally(() => {
            console.log(100);
        })

    // promise三种状态
    // pending   --> fulfilled
    //           --> rejected
    // 状态一旦被决议，就不能被修改。

    // Promise.all()   将多个Promise实例包装成一个新的Promise实例
    // Promise.all([promise1, promise2])
    // 传入一个 promise的数组  返回新的promise对象。   注意： 传入的需要是promise对象， 我们定义的函数返回值才是promise对象，所以，传入的内容必须是函数返回值， 要么是函数返回值传入一个变量保存，然后放到数组，要么就传入函数的执行, [getData1(), getData2(), getData3()]
    // Promise。all() 传入的数组如果不是Promise对象数组，会自动对数组中的每一项进行Promise.resolve()包装。
    // 数组中所有promise决议成功，最后的promise就成功，有一个失败就是失败
    // 模拟需要获取多个数据才能执行的案例
    function getData1(){
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log('第一条数据加载成功');
                resolve('data1');
            },1000);
        });
    }
    function getData2(){
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log('第二条数据加载成功');
                resolve('data2');
            },1000);
        });
    }
    function getData3(){
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                // console.log('第三条数据加载成功');
                reject('data3 error');
            },500);
        });
    }
    // 注意：数组中传入 primise对象，函数执行后返回值才是promise对象
    let p = Promise.all([getData1(), getData2(), getData3()]);
    // p 仍然相当于一个Promise，有then方法，接受的是一个promise数组
    p.then(arr => {
        console.log(arr);
    },e => {
        console.log(e);
    })
    // data3 error        第一条数据加载成功       第二条数据加载成功
    // 可以获取到原promise对象成功或者失败的参数，有一个失败，新的promise会执行失败，但是原来的其他promise 的resolve一样会执行

    let p2 = Promise.all([]);
    p2.then(() => {             // 没有参数传进来，会直接执行resolve
        console.log(arr);
    })

    // 没有promise实现上述功能
    let count = 0;       // 统计执行成功的方法个数
    let err = false;     // 判断是否有失败

    function fun(){
        if(count < 3)	return;
        if(err)	{
            console.log('执行失败操作');
        }
        console.log('数据全部拿到了');
    }
    function getData1(){
        setTimeout(() => {
            console.log('第一条数据加载成功');
            // if(status)	err = true;   设置一个状态参数，判断是否失败
            count ++;      // 当前函数执行成功，计数器加1
            fun();         // 判断是否全部执行完，是否有错
        },1000);
    });
    function getData2(){
        setTimeout(() => {
            console.log('第二条数据加载成功');
            count ++;
            fun();
        },1000);
    });
    function getData3(){
        setTimeout(() => {
            console.log('第三条数据加载成功');
            count ++;
            fun();
        },500);
    });
    getData1();
    getData2();
    getData3();

    // Promise.race([promise1, promise2])  返回一个新的Promise
    // 有一个决议为失败或者成功，立刻生成新的promise并对应决策为失败或成功
    function getData1(){
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log('第一条数据加载成功');
                resolve('data1');
            },300);
        });
    }
    function getData2(){
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log('第二条数据加载成功');
                resolve('data2');
            },1000);
        });
    }
    function getData3(){
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                console.log('第三条数据加载失败');
                reject('data3 error');     // 这个最先决策，所以会返回
            },500);
        });
    }
    let p = Promise.race([getData1(), getData2(), getData3()]);
    p.then(data => {
        console.log(data);
    }, e => {             // 同样可以获取参数
        console.log(e);
    })
    //  以上代码执行结果   第一条数据加载成功   data1   第三条数据加载失败   第二条数据加载成功
    // getData1最快，先输出，然后立刻生成新的Promise并决议为成功，获取到data1并输出，然后getData3执行，能输出，决议为失败，但是getData3没有失败处理，同时新的Promise也不会因此决策失败，所以什么都不做，继续执行getData2，输出

    let p2 = Promise.race([]);
    p2.then(() => {             // 没有参数传进来，就会被挂起，什么都不做
        console.log(arr);
    })

    // 没有Promise.race实现上述功能
    let flag = false;          // 判断是否有成功的
    function fun(data){
        if(flag)	return;    // 如果没有成功执行的，该函数什么都不会做
        flag = true;           // 一旦有成功的，该函数修改flag为true，并且根据获取到的数据执行了对应操作。  由于flag被修改了，之后的fun什么都不会做，直接return
        console.log(data);
    }
    function getData1(){
        setTimeout(() => {
            console.log('第一条数据加载成功');
            fun({name: 'xiaoming'});
        },500);
    }
    function getData2(){
        setTimeout(() => {
            console.log('第二条数据加载成功');
            fun({name: 'xiaohong'});
        },600)
    }
    getData1();
    getData2();
    // 结果  第一条数据加载成功    name: 'xiaoming'    第二条数据加载成功


    // Promise.resolve    生成已经决议为成功的Promise实例，并可以传递参数
    // 一、传递一个普通的值
    let p1 = new Promise(resolve => {
        resolve('success');
    })
    let p2 = Promise.resolve('success');   // 跟上述功能一样
    // 所以可以脱离写函数，来创建新的promise对象，直接使用Promise.resolve。  之前写函数，只有一个功能，return一个Promise实例，实例里面包含resolve和reject方法。

    // 二、传递一个promise对象     相当于直接吧这个Promise实例传递到新的变量。
    let promise11 = new Promise(resolve => {
        resolve('success');
    });
    let p = Promise.resolve(promise11);
    p.then(data => void console.log(data));
    // 相当于promise11.then(data => void console.log(data));
    console.log(p == promise11);    // true

    // 三、接受一个thenable对象(具有then方法的对象，跟promise类似)   可以转化成promise
    let obj = {        // 一个thenable对象，包含then方法
        then(cb) {
            console.log('run');
            cb('11');
        },
        oth() {
            console.log('drop');
        }
    }
    // 立即执行thenable对象的then方法   并可以传入一个回调，
    Promise.resolve(obj).then(data => {
        console.log(data);      //  输出 11  相当于thenable对象then方法的回调函数
    })

    // Promise.reject()   不管传入什么都原封不动的传递出去
    Promise.reject({ then() {console.log(1)}})
        .then( () => {
            console.log('永远不会被执行');
        }, e => {
            console.log(e);         // {then: f}   返回{ then() {console.log(1)}}这个函数。
        })

    // 小案例
    console.log(1);
    let p = new Promise(resolve => {
        console.log(2);
        resolve();
        console.log(3);
    });
    console.log(4);
    p.then( () => {
        console.log(5);
    });
    console.log(6);
    // 输出 1 2 3 4 6 5
    // 除了 p.then( () => {} )  其他所有 1 2 3 4 6 都是同步任务，直接按顺序输出。   2输出完了，resolve()的时候，调用异步任务，但是是排在所有同步任务之后

    // 把同步任务转成异步任务
    function createAsyncTask(syncTask){
        // 传入一个同步任务，利用Promise.resolve()生成一个决议成功操作是syncTask的Promise对象,并将syncTask传入，然后这个对象的then方法就可以拿到并 调用syncTask
        return Promise.resolve(syncTask).then(syncTask => syncTask())
        // syncTask => syncTask()   接受的变量为syncTask函数，然后调用执行这个变量。  这里的变量名可以修改。
        // return Promise.resolve(syncTask).then(task => task())
    }
    // 调用 传入一个函数
    createAsyncTask( () => {
        console.log('被修改为异步任务了');
        return 1 + 1;
    }).then( res => {
        // then 里面第一个参数res拿到的是promise对象resolve函数的返回值。即syncTask函数的返回值，即 1 + 1
        console.log(res);
    });
    console.log('这里是同步任务');
    // 输出： 这里是同步任务      被修改为异步任务了      2
    // 尽管同步任务在后面，还是先执行同步任务，然后执行异步任务的resolve函数，执行完了在执行then里面调用成功的操作



    // 案例
    // 页面中有板块 需要多张图片加载完之后才能进行显示
    const loadImg = (src) => {
        // 返回的Promise对象需要传入resolve和reject参数
        return new Promise((resolve, reject) => {
            const img = new Image();  // new 一个Image对象
            img.src = src;
            // Image对象自带onload参数，Image加载完成的时候会自动执行。 相当于图片加载完成自动执行resolve函数
            img.onload = () => {
                resolve(img);
            }
            // 同理 图片加载失败调用reject， onerror默认会传入一个错误信息e
            img.onerror = (e) => {
                reject(e);
            }
            // img.onload = resolve(img); 这样写是错误的，这样会先调用resolve，然后返回值传给img.onload 。
        })
    }
    const imgs = [
        'http://a0.att.hudong.com/64/76/20300001349415131407760417677.jpg',
        'http://img0.imgtn.bdimg.com/it/u=2608870614,758445612&fm=26&gp=0.jpg',
    ];
    // Promise。all() 传入的数组如果不是Promise对象数组，会自动对数组中的每一项进行Promise.resolve()包装。
    // 对数组imgs建立一个map映射， 传入一个函数， 对imgs数组中每一个对象进行操作，返回值传回到数组中。 现在 all里面传入的是一个Promise数组
    // 对于每个图片都有一个Promise对象，每个Promise对象都成功执行(成功加载图片)的时候，才会调用resolve(img)，传入Image对象， 所有Promise对象都创建完切成功执行，才会forEach循环添加图片。
    Promise.all(imgs.map(src => loadImg(src))).then((arr) => {
        console.log(arr);     // 这里then里面传入的是resolve传入的参数，即两个Image对象， 然后执行 决议成功的操作。
        arr.forEach((img) => {
            // forEach遍历数组对象，获取到每个Image对象，然后添加到页面
            document.body.appendChild(img);
        })
    });
    // 可以拆开理解
    const promises = imgs.map((src) => {
        return loadImg(src);
    });
    Promise.all(promises).then((arr) => {
        arr.forEach((img) => {
            document.body.appendChild(img);
        })
    }).catch((e) => {     // 可以加入错误捕获。 没有reject函数，就会运行到catch。 默认传入错误信息e。
        console.log(e);
    });
    // 在图片地址数组中传入一个错误地址，图片无法加载，就会调用Image.onerror() 即调用reject。 没有reject方法，但是Promise对象的决议已经变成了失败，所以一直会执行到catch。
    const imgs = [
        'http://a0.att.hudong.com/64/76/20300001349415131407760417677.jpg',
        'aa',
    ];
    // 结果
    // aa:1 GET file:///C:/Users/82601/aa net::ERR_FILE_NOT_FOUND
    // Event {isTrusted: true, type: "error", target: img, currentTarget: img, eventPhase: 2, …}


    // 类  面向对象
    // 利用自运行的函数 实现贪吃蛇。   当要新添一条蛇的时候，需要复制，然后修改变量名
    (function() {
        let snake = []; //存放蛇身的
        let food = { x: 0, y: 0 }; // 食物的坐标
        function move() {
            // 处理蛇的移动
        }
        start();
    })();

    class Car {
        // 构造函数的名字 是固定的 必须是constructor
        constructor(...args){

        };
    }
    new Car('blue',2);    // 这样 args = ['blue',2]

    class Car {
        // 构造函数
        constructor(color,wheels,length,width){
            this.color = color;
            this.wheels = wheels;
            this.length = length;
            this.width = width;

            this.speed = 0;
        };
        // 方法
        speedUp(){
            this.speed += 1;
        }
    }
    const car = new Car('blue',4,20,40);    // 这样 args = ['blue',2]
    console.log(car.color);
    console.log(car.speed);
    car.speedUp();
    console.log(car.speed);


    // 范例  音乐播放器
    class AudioPlayer{
        constructor(container){
            this.container = document.querySelector(container);
            this.songsList = [];  // 歌单列表
            this.dom = null;      // 存放dom
            this.audio = new Audio();    // Audio对象
            this.status = 0;      // 标记播放器状态

            this.getSongs();
            this.createElement();
            this.bindEvents();
            this.render();
        }

        getSongs(){
            //  ... ajax
            this.songsList = {
            {
                cover: '',
                    url: '  .mp3',
                singer: {},
                name: '',
            }
        }
        }

        createElement(){
            const div = document.createElement('div');
            div.innerHTML = `
    			<div class='btn'>播放按钮</div>
    			<div>进度条</div>`;
            this.dom = div;
        }

        bindEvents(){
            this.dom.querySelector('.btn').addEventListener('click', () => {
                console.log('开始播放');
            });
        }

        render(){
            this.container.appendChild(this.dom);
        }
    }

    new AudioPlayer('#app');
    new AudioPlayer('#bpp');

    // 静态方法和属性     静态方法用static声明  静态属性通过 类名.属性名 =
    // 静态方法和属性不能通过类的实例对象调用，  只能通过类调用
    class Car{
        constructor(){
            this.speed = 0;
        }
        speedUp(){
            this.speed += 1;
        }
        static repair(carNumber){
            console.log('我是修车的');
            console.log('我现在要修的车是：',car);
        }
    }
    Car.repair('1号车');        // '我是修车的'    '我现在要修的车是：1号车'
    new Car().repair('1号车');   // 报错 找不到这个方法

    class Car{
        constructor(){
            Car.totalCar += 1;    // 每次new一个对象，都把这个类的统计数量的静态属性加一
            this.speed = 0;
        }
        speedUp(){
            this.speed += 1;
        }
        static repair(car){
            if(!car.speed){
                car.speed = 0;
            }
            console.log(car);   // color: "blue"   speed: 0
        }

        checker(){                 //  普通方法和静态方法重名 没有问题的

        }
        static checker(){

        }
    }
    // 例如 经过一系列操作，丢失了car这个实例对象的spedd属性，只剩下color，可以调用类的静态方法执行处理修复
    Car.repair({color: 'blue'});      // 这个car只有 color属性了

    // 静态属性  类名.属性名 =     来声明    也通过这种方式来访问
    Car.totalCar = 0;    // 计算总共生成了多少个实例对象
    Car.config = {
        wheels: 4,
        color: 'white',
    }

    class Character {
        constructor(pfs){
            this.pfs = pfs;
        }
    }
    class Profession{

    }
    Profession.config = {
        profession:{
            '咒术师': 1,
            '弓箭手': 2,
        }
    }
    new Character(Profession.config.profession['咒术师'])；

    // 类 之间转换
    class Person{
        static format = programmer => {
            programmer.haveGirlfriend = true;
            programmer.hair = true;
        }
    }
    class programmer{
        constructor(){
            this.haveGirlfriend = false;
            this.hair = false;
        }
    }
    const programmer = new Programmer();
    console.log(programmer);
    Person.format(programmer);
    console.log(programmer);      // 属性值已经发生了改变

    // 类表达式
    // 最简单的形式
    const Person = class {
        constructor(){
            console.log('I am person');
        }
    }
    // class后面可以加类名，但是只能在类里面访问
    const Person = class P{
        constructor(){
            console.log(P);
            console.log(P == Person);     // true
            console.log('I am person');
        }
    }
    new Person();
    console.log(P);    // 报错


    // getter / setter
    // ES5 中
    // 1.在对象字面量中书写get/set方法   相当于钩子，在获取/设置属性值的时候进行额外的操作
    const obj = {
        _name: '',
        // 这里get后面的方法名 是自己设置，表示 获取/设置 对象的这个属性名的时候会调用这个方法。  如果有个属性名是name,然后get name(){ return this.name }; 会出现无限循环，this.name 会继续调用get name方法。
        get name(){
            console.log('getter');
            return this._name;
        },
        // set 方法里面必然要传入一个参数，这个参数是赋值操作右边的值。  如下面的 222
        set name(val){
            console.log('setter');
            this._name = val;
        }
        // 这样相当于对 obj.name属性操作的时候 都是对 _name 进行操作
    }
    obj.name = 222;                // 自动执行set操作   输出 getter
    const objName = obj.name;      // 自动执行get操作   输出 setter
    console.log(obj);              // {name: '222'}
    // 2. Object.defineProperty
    var obj = {
        _name: '',
    };
    Object.defineProperty(obj, 'age', {
        value: 19,
        enumerable: true,   // 是否可被枚举的描述符。 如果为false，obj里面有这个属性，但是遍历的时候无法遍历到这个属性
    });
    for(var i in obj){
        console.log(i);
    }

    var obj = {
        _name: '',
    };
    Object.defineProperty(obj, 'name', {
        get: function(){
            console.log('正在访问name');
            return this._name;
        },
        set: function(val){
            console.log('正在修改name');
            this._name = val;
        }
    });
    obj.name = 10;
    console.log(obj);

    class Person{
        constructor(){
            this._name = '';
        }
        get name(){
            console.log('正在访问name');
            return `我的名字是${ this._name }`;
        }
        set name(val){
            console.log('正在修改name');
            this._name = val;
        }
    }
    const person = new Person();
    person.name = 'xiaoming';      // '正在修改name'
    console.log(person.name);      // '正在访问name'   我的名字是xiaoming


    // Audio Player例子
    class AudioPlayer{
        constructor(){
            // 0-pause   1-play    2-loading
            this._status = 0;
            this.status = 0;   // 初始化调用set 把它设置为0
            this.init();
        }

        init(){
            const audio = new Audio();   // 自带的对象Audio
            audio.src = '.....';

            audio.oncanplay = () => {    // 这里如果不用箭头函数 用 function(){}   那么里面的this指向就是audio，但此时我们要这个this指向AudioPlayer。   箭头函数里面的this并不是当前小环境，而是函数所处的大环境
                audio.play();
                this.status = 1;
            }
        }
        get status(){
            return this._status;
        }
        set status(val){
            const STATUS_MAP = {
                0: 'Pause',
                1: 'Play',
                2: 'loading',
            };
            // 修改按钮里面的内容
            document.querySelector('#app .play-btn').innerHTML = STATUS_MAP[val];
            this._status = val;
        }
    }
    const audio = new AudioPlayer
    audio.status = 1;    // 按钮的文字会变成 Play


    // name     返回类的名字   用得少
    // 直接声明类
    class Person{
    }
    console.log(Person.name);    // Person
    // 类表达式
    const Human = class {}
    console.log(Human.name);     //   Human
    const Human = class P{}
    console.log(Human.name);     //    P
    // new.target

    // new.target
    class Car {
        constructor(){
            console.log(new.target);
        }
    }
    new Car();     // new.target属性没法直接 访问，只能在类里面访问。 返回的就是 new出来的这个类

    // ES5中模拟类
    function Car(){
        console.log(new.target);
        if(new.target !== Car){
            throw Error('必须使用new关键字调用');
        }
    }
    // new 一个方法，就是把他当做构造函数。 new.target会返回这个函数本身。    如果没有new,直接 Car()， 输出的new.target 就是undefined。  所以可以利用和new.target是否等于函数本身，判断是不是通过new调用
    new Car();

    function Person(name, age){
        this.age = age;
        this.name = name;
    }
    // 利用函数模拟构造函数， 如果没有返回值，且用new调用函数，就会返回一个对象。
    console.log(new Person('张三',11));  // Person {age: 11, name: "张三"}
    // new 关键字调用函数的时候，发生了什么，为什么会得到一个新对象
    // 1.创建一个空对象
    // 2.把构造函数的prototype属性 作为空对象的原型(同时也有了prototype的方法，  this.age 就是原型的this方法)
    // 3.this赋值给这个空对象
    // 4.执行函数
    // 5.如果函数没有返回值 就返回这个this对象
    // 用代码表述上述过程
    function Constructor(fn, args){
        var _this = Object.create(fn.prototype); // Object.create()里面穿入一个对象，作为新的object的原型。
        // 对这个空对象调用fn函数，传入args参数
        // 改变 fn里this的指向，即下面Person里面this的指向
        var res = fn.apply(_this, args);   // res是函数的返回值
        return res ? res : _this;    // 如果有返回值，就返回返回值，没有返回值就返回这个对象
    }
    function Person(name, age){
        this.name = name;
        this.age = age;
    }
    Person.prototype.say = function(){
        console.log('我叫' + this.name);
    }
    var person = Constructor(Person,['张三', 12] );
    console.log(person);      // Person {name: "张三", age: 12}

    // 继承   extends

    class Human{
        constructor(name, age, sex, hobby){
            this.name = name;
            this.age = age;
            this.sex = sex;
            this.hobby = hobby;
        }
        // 父类的方法 是放到父类的原型上的
        desc(){
            const {name, age, sex, hobby} = this;
            console.log(`我叫${ name }，性别${ sex }，爱好${ hobby }， 今年${ age }岁。`);
        }
        eat(){
            console.log('I am eating');
        }
        checkThis(_this){
            console.log(_this == this);
        }
    }
    Human.total = 899999;
    class FEEngineer extends Human{
        constructor(name, age, sex, hobby,skill,salary){
            // 子类调用this之前，必须调用父类的构造函数，即可以通过super（）来调用
            super(name, age, sex, hobby);
            this.skill = skill;
            this.salary = salary;
        }
        // 这样无法传递父类的属性。  只能创建  只带有子类特殊属性的对象。
        // constructor(skill,salary){
        // 	super();
        // 	this.skill = skill;
        // 	this.salary = salary;
        // }
        say(){
            console.log(super.eat);        // f eat(){ ... }    super可以访问到父类方法  非静态方法中 super是父类原型，父类方法都是在父类原型上
            console.log(super.eat);        // 也可以调用
            console.log(super.checkThis(this));    // true   在调用super的时候，父类的this始终是子类的this
            console.log(this.skill.join());
        }
        static test(){
            console.log(super.name);    // Human   静态方法中 super就是父类。  super.name是自带的方法，返回父类名称
            console.log(super.total);  // 可以访问到父类的静态属性
        }
    }
    const feer = new FEEngineer(
        'xiaohong',
        12,
        'Female',
        'singing',
        ['es6','vue'],
        '1k',
    );
    feer.desc();  // 我叫xiaohong，性别Female，爱好singing， 今年12岁。
    feer.say();    // es6,vue
    FEEngineer.test();    // Human


    // super()
    // 作用1： 作为父类构造函数调用  将子类的this传递给父类的构造函数  然后把父类的构造函数跑一遍
    // 作用2： 作为对象的方式调用
    // 1.非静态方法中访问super -> 父类原型
    // 2.静态方法中访问super -> 父类

    // 在调用super的时候  父类的this 始终是子类的this


    // 多态    重写（子类中重写父类方法）
    class Human{
        say(){
            console.log1('I am human');   // I am human
        }
    }
    class Man extends Human{
        say(){                 // 这里是重写，区别于重载
            super.say();        // I am human
            console.log1(' Man');
        }
    }
    class Women extends Human{
        say(){
            super.say();          // I am human
            console.log1('Women');
        }
    }
    new Man().say();     // Man
    new Women().say();   // Women
    // 重载
    class SimpleCalc{
        addCalc(...args){
            if(args.length === 0){       // 这里三个return就相当于重载。
                return this.zero();
            }
            if(args.length === 1){
                return this.onlyOneArgument(args);
            }
            return this.add(args);
        }
        zero(){
            return 0;
        }
        onlyOneArgument(){
            return args[0];
        }
        add(args){
            return args.reduce((a,b) => a + b, 0);   // 做累加 a是起始元素，b是遍历元素，0是起始元素默认值
        }
    }
    // 另一种重载操作
    function post(url,header,parmas){
        if(!parmas){     // 相当于重载 为一个方法添加多种实现功能   区别于重写（子类中重写父类方法）
            parmas = header;
            header = null;   // undefined
        }
    }
    post('https://imooc.com',{
        a: 1,
        b: 2,
    })

    // 利用重载 实现预留接口（只允许子类去实现，相当于java抽象方法）
    class Monster{
        constructor(name, level, model){
            this.model = model;
            this.name = name;
            this.level = level;
        }
        attack(){
            throw Error('必须由子类来实现attack攻击方法');
        }
    }
    const ModelMap = {
        '红眼僵尸'： 1,
        '绿眼僵尸': 2,
    }
    class RedEyeZombie extends Monster{
        constructor(){
            super('红眼僵尸'， 10， ModelMap['红眼僵尸']);
        }
    }
    class GreenEyeZombie extends Monster{
        constructor(){
            super('绿眼僵尸'， 10， ModelMap['绿眼僵尸']);
        }
        attack(){
            console.log('绿眼僵尸发动攻击');
        }
    }
    const gez = new GreenEyeZombie();
    gez.attack();       // 绿眼僵尸发动攻击
    const rez = new RedEyeZombie();
    rez.attack();      // Error '必须由子类来实现attack攻击方法'
    // 子类如果没有attack方法，会自动调用父类attack，此时就会报错。这样就达到了必须由子类实现方法的目的。    必须在子类中重写attack方法

</script>

<!--再学ES6-->
<script>


</script>
</body>
</html>