<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>


<script>
    <!--
    script标签
    可以放在head也可以放在body里面-->
    <!--//<script src=""> 外接-->
    <!--<script>   也可以直接在里面写-->
    // 变量前面需要var声明

    var name_01;
    name_01 = "marry"
    var name = "marry", age = "18";
    //用于保存对象的变量最好初始化为null
    student = null
    undefined == null    // True
    // 省略var的变量是全局变量
    console.log(name_01)  //打印
    typeof name_01   //（声明了一个变量，没有赋值，他的类型就是undefined）
    typeof (name_01)  // 两种格式，检测变量类型

    // Number：整数或浮点数
    // NaN：非数值  是一个特殊的数值
    // 16-'abc'   返回 NaN
    // 但是 typeof（16-'abc'） 返回 Number
    // 任何涉及NaN的操作，都会返回NaN ，例如 ： NaN/10
    // NaN与任何值都不等，包括它本身
    // isNaN（a）  检测a是否是非数值   他会对绝收的数值，先尝试转化为数值，再检测是否是数值
    // eg：id="16"   id是个字符串，但是 isNaN（id） 会返回False。  因为id可以转化为一个数值

    //三种强制类型转化为数值  遇到转化不了的字符串，返回NaN
    Number()
    parseInt()
    parseFloat()
    topval = " 28px"
    parseInt(topval)  // 返回一个数值28。  要求字符串必须以数字开头才可以筛选转化。而且会自动从第一个非空的开始转化
    topval = "abc58"   // 无法转化
    parseInt("")  //转化空字符，返回NaN
    parseInt()   //第二个参数为进制
    console.log(parseInt("0xf"))  //可以输出15。  等同于parseInt（"0xf"，16）
    parseInt("12。34px")    // return 12
    parseFloat("12.34px")  // return 12.34
    parseFloat("12.34.56px")  // return 12.34  只会识别第一个小数点

    str.toString();  // 任何类型包括null undefied 都可以用

    // 0，" "，null，undefined 为false，其他所有字符和数字都为true

    ++a;  // 先返回递增之后的a的值
    a++;  // 先返回a原值，在返回递增之后的值
    var num1 = 10, num2 = "5";
    console.log(num1 - num2);  // 隐式转化，会自动把字符串转化成数字

    alert("");  // 弹出警告框
    var password = promt("请设置您的密码")   // 会弹出一个警告框，有一个输入框
    if (password.length != 6) {
        alert("请输入六位数字密码");
    } else {
        if () {
        } else {
        }
    }

    var week = new Date().getDay();   // 返回星期几
    document.write("内容")  // 向浏览器中输出内容
    switch (week) {
        case 0:
            document.write("今天是星期日");
            break
        case 6:
            document.write("今天是星期六");
            break
        default:
            document.write("j今天不是周末");
    }

    // 定义function  可以进行参数返回
    function functionName(arg1, arg2, ..) {

        return sum;
    }

    // arguments对象只是与数组类似，并不是array的实例
    function inner() {
        // arguments 是内置的
        console.log(arguments.length);  // 输出2
        console.log(arguments[2]);      // 输出5
    }

    inner(10, 5);

    function add(num1, num2) {
        arguments[0] = 99;
        console.log(num1);
    }

    add(1, 2);          // 结果是 99 + 1 = 102   修改了第一个传入的参数

    function getAvg() {
        var sum = 0, len = arguments.length, i;
        for (i = 0; i < len; i++) {
            sum += arguments[i];
        }
    }

    getAvg(1, 2, 3, 4, 5);    //  可以求平均数


    // ------------内置对象--------------

    // 1。Array
    new Array()   // 可以传入数组容量，可以用[]传递内容。  初始化的数组容量，并不限制之后扩容，可以直接增加元素
    var color = new Array(3);
    var color = new Array(1, 3, 6, 9);
    console.log(color);           // [1,3,6,9]
    console.log(color.length);    //  4
    var color = [6, "marry", true]   // 可以存储混合类型

    // 数组栈方法
    push()
    arr.push(newx);    // 添加参数到最后，返回新长度，可同时push多个进去
    unshift()
    arr.unshift(newx);  // 添加参数到最开头，返回新长度，可同时添加多个
    pop()
    arr.pop()   // 删除最后一个元素，返回被删除元素
    shift()
    arr.shift();   // 删除第一个元素，返回被删除元素
    join(separator)
    arr.join()    // 把所有元素放入一个字符串，返回字符串。  默认数组元素之间插入逗号
    arr.join('')   // 什么都不加，直接连起来
    // 例如：arr=[1,2,3,4]   arr.join()   返回 "1，2，3，4"    arr.join("-")  返回 "1-2-3-4"
    reverse()
    :
    arr.reverse();   // 颠倒数组元素顺序，返回数组
    sort();
    arr.sort(sortby);  // 对数组元素排序， 返回数组，    哪怕传入的是数值，也是比较字符串。例如：12 9 23 会返回 12 23 9   现比较首字母
                       // sort（）可以接受比较函数作为参数。   例如： arr.sort(function(a,b){return b-a})  从大到小排序
    concat();
    arr.concat(array1, array2, ...);  // 用于连接一个或多个数组  返回新数组
    slice();
    arr.slice(start, end)   // 返回选定的区间的元素。 start必需，开始，负数从尾部开始算起。  end可选，结束（不包含）。没有end默认到结尾。返回数组
    // 复制数组方法：  1。for循环遍历， b.push(a[i])   2。b=[].concat(a)    3.b=a.slice(0)
    splice();   // 删除/插入/替换
    arr.splice(index, count)   // 删除从index开始 count个元素，返回被删除的元素。  count=0不删除，不设置count删除从index到结尾
    arr.splice(index, 0, item1, item2
    ...)    // 从index开始，删除0个，插入item1，item2，。。。    返回新数组
    arr.splice(index, count, item1, item2
    ...)    // 从index开始，删除count个，插入item1，item2，。。。 相当于替换   返回删除元素
    indexOf();
    arr.indexOf(searchvalue, startIndex)    // 从startIndex（可选，不要的话就是从0开始）开始查找searchvalue（必需）。  返回数组下标，没有返回-1

    // 2。String
    charAt();
    string.charAt(index);  // 返回index位置的字符，    IE7以后的浏览器可以用过 方括号+字符 索引
    charCodeAt();
    string.charCodeAt(index);   // 返回index位置字符的编码
    indexOf();
    string.indexOf("o");   // 返回字符串的位置，没有找到返回-1
    slice();
    string.slice(start, end);  // start必须，end可选   负数从尾部开始算
    substring();
    string.substring(statr, end);   // 同slice，但是为负数时，自动转化为0。自动把较小的作为开始，较大的作为结束
    substr();
    string.substr(stat, len);  // 从start开始截取长度为len。  start必须，len可选。  start为负数，从末尾开始算。 len为负数，返回空
    split();
    string.split(separator);  // 将字符串分割成字符串数组。  返回Array。   separator必须，分割符
    replace();
    string.replace(regexp / substr, replacement);  // regex必须，正则表达式。或者一个子字符   replacement必须，替换之后的子字符串
    toUpperCase() / toLowerCase();
    string.toUpperCase();
    string.toLowerCase();

    // 3.Math
    min();   // 传入多个数，求最小
    max();
    ceil();   // 向上取整，大于num的最小整数
    floor();  // 向下取整
    round();   // 四舍五入取整
    abs();   // 取绝对值
    random(); // 返回 大于等于0，小于1的随机数。  求n到m之间随机整数：  random=Math.floor(Math.random()*(m-n+1)+n);

    // 4.Date
    var date = new Date();          // 创建一个日期时间对象，不传参情况下，返回当前日期时间对象
    // 创建特定日期和时间的对象，必须穿入改日期的毫秒数，或者用逗号隔开的表示年月日时分秒的参数
    getFullYear();  // 4位数年份
    getMonth();    // 日期中的月份  0-11
    getDate();     // 月份中的天数
    getDay();      // 返回星期  0-6
    getHours();    // 小时
    getMInutes();  // 分
    getSeconds();  // 秒
    getTime();   // 表示日期的毫秒数   从1970年1月1日0：00：00开始到现在的时间的毫秒数
    // 以上七个方法，把get改成set  是设置相应参数的方法   setTime()  会修改整个日期
    // 例如：求50天之后是星期几  方法一：  var today=new Date();     today.setDate(today.getDate()+50);   console.log(today.getDay());
    //  方法二：  var today=new Date();      var temp=new Date(today.getFullYear(),today.getMonth(),today.getDate() + 50)  创建一个今天日期加五十天的对象
</script>


// -------------------------------DOM 操作-------------------------------
// 创建节点：
document.createElement(); // 创建html标签结点
document.createTextNode(); // 创建文本结点
document.createDocumentFragment(); // 创建文档片段
document.createComment(); // 创建注释文本
<ul id="myList"></ul>
<div id="content"></div>

<script>
    // 这种 function写法，立即调用，且不会污染整个环境
    (function () {
        var ul = document.getElementById("myList");   // 获取ul这个标签
        var li = document.createElement("li");    // 创建一个元素结点，li元素
        var txt = document.createTextNode("Item");  // 创建一个文本节点
        li.appendChild(txt);   // 先在li里面插入文本
        ul.appendChild(li);   // 然后 在ul里面插入li
    })();

    // create fragment  && comment
    (function () {
        var comment = document.createComment("This is a comment");   // 创建一个comment结点，即在html中插入注释  <!--This is a comment-->
        var fragment = document.createDocumentFragment();
        var ul = document.getElementById("myList");
        var li = null;
        for (var i = 0; i < 3; i++) {
            li = document.createElement("li");
            li.appendChild(document.createTextNode("Item" + (i + 1)));
            fragment.appendChild(li);      // 这个fragment 填充进去了三个标签
        }
        ul.appendChild(fragment);
        document.body.insertBefore(comment, document.body.firstChild);   //     在body的第一个子结点前面插入注释结点。
    })();

    // innerHTML   设置或获取当前标签的起始和结束里面的内容
    (function () {
        var content = document.getElementById("content");
        var str = "<p> This is a <strong>paragraph</strong> with a list folloing it</p>"
            + "<ul>"
            + "<li>Item 1</li>"
            + "<li>Item 2</li>"
            + "</ul>";
        var round = "<style type = \"text/css\">body {background-color: red;}</style>";   // 可以插入css内容
        // 注意，对于IE浏览器，插入css不会直接生效，javascript也是。 需要在标签前面加入一个空白标签，然后innerHTML之后再移除
        // var round = "_<style type = \"text/css\">body {background-color: red;}</style>";
        // content.innerHTML = round;
        // content.removeChild(content.firstChild);
        content.innerHTML = str;
        content.innerHTML = round;
    })();

    // outerHTML 返回调用它的元素及所有子节点的HTML标签
    (function () {
        var content = document.getElementById("content");
        console.log(content.outerHTML);   // 打印输出包括content这个标签在内的，里面的HTML结构
        console.log(content.innerHTML);   // 打印content这个标签里面的，不包括content
        content.outerHTML = "<p>This is a paragraph</p>";  // 覆盖掉content标签，里面的内容也都没了。  用<p>This is a paragraph</p> 替代
    })();

    // innerText  设置或获取位于对象起始和结束标签内的文本   火狐浏览器换成 textContent
    (function () {
        var content = document.getElementById("content");
        console.log(content.innerText);   // 打印输出包括content这个标签在内的，里面的纯文本，不包含标签
        content.innerText = "<p>This is a paragraph</p>";  // content里面的内容没了。用<p>This is a paragraph</p> 替代。但是，这个p标签是被当作纯文本输入了
    })();
    // 为了支持多浏览器，可以加入判断，浏览器支持textcontent还是innertext.
    (function () {
        var content = document.getElementById("content");
        // 支持获取innertext
        function getInnerText(element) {
            return (typeof element.textContent == "string") ? element.textContent : element.innerText;
        }
        // 支持写入innertext
        function setInnerText(element, text) {
            if (typeof element.textContent == "string") {
                element.textContent = text;
            } else {
                element.innerText = text;
            }
        }
        setInnerText(content, "Hello world!");
        console.log(getInnerText(content));
    })();

    // outerText     尽量不使用这个

</script>


<!------------------------遍历节点-------------------------->
<p id="paragraph">文本叶子结点</p>
<ul id="box" data-url="index.html" node-action="submit">
    <li>节点一</li>
    <li>节点二</li>
    <li>节点三</li>
</ul>

<script>

    // 遍历节点(包含元素节点和空白节点)
    // 父node得到子node：  firstChild｜lastChild｜childNodes[1]或childNodes.item(1)
    // 子node得到父node:   parentNode
    // 子node得到子node：  nextSibling｜previousSibling
    (function () {
        var oHTML = document.documentElement;    // documentElement 返回文档的根节点
        console.log(oHTML.tagName);   // tagName返回元素的标签名   会输出html
        var oHead = oHTML.childNodes[0];
        //  等同于  var oHead = oHTML.childNodes.item(0);
        console.log(oHead);   //  会输出整个<head> 以及里面的内容
    })();

    // ownerDocument 获取根部的文档节点。
    // hashChildNodes()  看是否有孩子节点
    (function () {
        var p = document.getElementById("paragraph");
        var txt = p.childNodes[0];
        console.log(p.ownerDocument == document);   //  true
        console.log(p.hasChildNodes());   //   true
        console.log(txt.hasChildNodes());   //  false
    })();

    (function () {
        var box = document.getElementById("box");
        for(var i = 0, len = box.childNodes.length; i < len ; i++){
            console.log(box.childNodes[i]);    // 本来只有三个li，但是最后输出了7个节点，包含四个空白文本节点。分别是ul到第一个li，第一个li到第二个li。。之间的空格
        }
    })();
    // 利用元素节点的nodeType == 1， 判断只输出元素节点
    (function () {
        var box = document.getElementById("box");
        for(var i = 0, len = box.childNodes.length; i < len ; i++) {
            if (box.childNodes[i].nodeType == 1) {
                console.log(box.childNodes[i]);
            }
        }
    })();
    // 遍历元素节点(不包含空白节点)
    // 父node得到子node：  firstElementChild｜lastElementChild｜children[1]
    // 子node得到子node：  nextElementSibling｜previousElementSibling
    // 获取当前元素节点内所有元素节点个数  childElementCount

    // NodeList 类数组对象，保存有序的节点   可以通过方括号访问NodeList的值，有item和length属性，不是Array实例，没有数组方法。
    (function () {
        var box = document.getElementById("box");
        var nodes = box.childNodes;
        console.log(nodes);  // [text, li, text, li, text, li, text]
        console.log(nodes[1]);   // <li>节点一</li>
        console.log(nodes.item(1));  // <li>节点一</li>
        // nodeList不是Array，无法使用push等数组方法，可以自己写一个function将其转化为array
        function makeArray(nodeList){
            var arr = new Array();
            for(var i = 0, len = nodeList.length; i < len; i ++){
                arr.push(nodeList[i]);
            }
            return arr;
        }
        // 也可以用Array下的prototype方法直接把nodeList转化为数组
        function makeArray2(nodeList){
            return Array.prototype.slice.call(nodeList);
        }
        // 但是一些IE浏览器不支持prototype。可以把两个综合
        function makeArray3(nodeList){
            var arr = null;
            try{
                return Array.prototype.slice.call(nodeList);
            }catch (e) {
                for(var i = 0, len = nodeList.length; i < len; i ++){
                    arr.push(nodeList[i]);
                }
            }
            return arr;
        }
        var newNodeList = makeArray(nodes);
        newNodeList.push();
    })();

    // HTMLCollection
    Ele.getElementsByTagName()  // 返回标签名相同的一组元素的集合
    document.scripts  // 返回所有的 <script> 标签
    document.links    // 返回所有的 <img> 标签
    document.images   // 返回所有的 <img> 标签
    document.forms   // 返回所有的 <form> 标签
    tr.cells        // 返回tr下的所有td单元格
    select.options   // select的全部选项
        // ...  还有很多，都是返回这些元素集合的 类元素集合对象
        (function () {
            var scripts = document.scripts;
            var cells = document.getElementById("tr").cells;
            var option = document.getElementById("select").options;
            cells.namedItem('td');  // 优先查找这个cell下面id ="td"的标签，如果没有，就会返回第一个name="td"的标签
        })();

    // NamedNodeMap
    Ele.attributes;      // 打印元素所有的特征属性
    (function () {
        var box = document.getElementById("box");
        var attrs = box.attributes;
        console.log(attrs);  // NamedNodeMap{0: id, 1: data-url, 2: node-action}
        console.log(attrs[0]);  // 也可以通过方括号和item访问
        console.log(attrs.item(1));
    })();

    // 类数组的动态性   NodeList，HTMLCollection，NamedNodeMap三个集合都是动态的，每当文本发生变化，他们都会更新

</script>


<!------------------------访问节点-------------------------->
<a name="target" href="">这是错误的元素</a>
<p id="target">这是正确的元素</p>
<button id="button">开始测试</button>

<script>
    // getElementById();    // 此方法前面对象必须是document。   返回该对象下Id为目标的所有元素的集合
    // getElementsByName();  // 此方法前面对象必须是document
    // getElementByTagName();  // 可以是元素对象也可以是element.
    // getElementByClassName();  // 可以是元素对象也可以是element  高级浏览器下可用
    // querySelector();      // 返回文档中匹配指定CSS选择器的一个元素   主流浏览器都支持
    // querySelectorAll();    // 返回文档中匹配指定CSS选择器的一组元素   主流浏览器都支持

    (function(){
        var bn = document.getElementById('button');
        bn.onclick = function () {
            var target = document.getElementById('target');
            console.log(target.innerHTML);   // 打印这个标签里面的内容
        }
    })();
    // 此时，对于google浏览器，会监测到id=target的p标签，打印"这是正确的元素"。 而IE会检测到第一个name=target的标签a 打印"这是错误的元素"
    // 修改getElementById，兼容所有浏览器.  只搜索id为target的元素
    (function(){
        var getElentById = function (id) {
            var el = document.getElementById(id);
            // 对于IE浏览器 \v转译为 v，然后"\v1"就是"v1"， + 强制转化为数字，可是"v1"第一个不是数字，就变成了 NaN  ！NaN就是 true
            // 对于其他浏览器， \v转化为 制表符，相当于空格， "\v1" 就相当于 " 1"  强制转化数字是从第一个非空开始，所以可以转化为数字1
            if(!+"\v1"){
                if(el && el.id == id){
                    return el;
                }else{
                    var els = document.all[id],
                        n = els.length;
                    for(var i = 0; i < n; i++){
                        if(els[i].id == id){
                            return els[i];
                        }
                    }
                }
            }
            return el;
        };
        console.log(getElentById("target"));
    })();

    // getElementByName和 ById类似。   对象必须是document， 但是在IE浏览器下，有bug，只会返回input和img元素，且会搜索id为target的元素
    // getElementByTagName  根据标签名获取
    (function(){
        var list1 = document.getElementsByTagName("li");
        var inputs = document.getElementsByTagName("input");
        var comment = document.getElementsByTagName("!");   // 返回所有注释
        console.log(inputs[0].value);    // 打印所有input框的第一个的value值
        console.log(comment[0].nodeValue);   // 打印第一个注释的内容，IE下会认为<!DOCTYPE html>是第一个。
        var all = document.getElementsByTagName('*');    // 获取所有的标签
        for(var i = 0, len = all.length; i< len; i ++){
            console.log(all[i].tagName);    // 打印出所有的标签
        }
    })();

    // getElementByClassName
    (function(){
        var ul = document.getElementsByClassName('myUl');
        var list1 = ul.getElemtsByClassName('light dark');  // 有多个类名。可同时获取，且不分先后顺序
    })();
    // 解决 getElementByClassName兼容性问题
    (function(){
        var getElementsByClassName = function (opts) {
            var searchClass = opts.searchClass;  // 存储要查找的类名
            var node = opts.node || document;    // 存储要查找的范围
            var tag = opts.tag || '*';       // 存储一定范围内要查找的标签
            var result = [];
            // 判断浏览器支不支持getElementsByClassName方法
            if(document.getElementsByClassName){  // 如果浏览器支持

            }else{  // 使IE8以下的浏览器能够支持该属性
                var els= node.getElementsByTagName(tag);
                var elsLen = els.length;
                var pattern = new RegExp("(^|\\s)" + searchClass + "(\\s|$)");
                for(i = 0,j = 0; i < elsLen; i ++){
                    result[j] = els[i];
                    j ++;
                }
            }
            return result;
        }
    })();

    // querySelector('#myUl');
    (function(){
        var myDiv = document.getElementById('myDiv');
        var ul = myDiv.querySelector('#myDiv');  // IE下必须用 document.querySelector('#myUl');
        var li = myDiv.querySelector('li:last-child');  // 所有选择器都可以
        var els = document.querySelector('input, li');  // 多个选择器，逗号隔开，但是只会找第一个，
        var span = document.querySelector('span');  // 找不到的选择器，会返回null
        var input = document.querySelector('.foo\\:bar');

        var ul = myDiv.querySelectorAll('li');   // 查找所有该选择器，返回集合
    })();
</script>


<!------------------------操作节点-------------------------->
    appendChild();    // 向该元素节点最后添加新节点， 返回该新的子节点
    insertBefore();     //  在指定的已有子节点之前插入新的子节点
    replaceChild();
    cloneNode();    // 创建节点的拷贝，返回该节点。   传入一个参数。
    normalize();
    splitTex();
<script>
    // appendChild();
    (function () {
        var ul = document.getElementById("myList");   // 获取ul这个标签
        var li = document.createElement("li");    // 创建一个元素结点，li元素
        var txt = document.createTextNode("Item");  // 创建一个文本节点
        li.appendChild(txt);   // 先在li里面插入文本
        ul.appendChild(li);   // 然后 在ul里面插入li

        var firstLi = ul.firstElementChild;
        ul.appendChild(firstLi);    //  这个操作会把第一个节点挪到最后，而不是复制。
    })();

    // insertBefore();   第一个为插入的新节点，第二个参数为插入位置  返回新插入的节点
    // replaceChild();    （要插入的节点，被替换的节点）   返回被替换的节点
    (function () {
        var ul = document.getElementById("myList");   // 获取ul这个标签
        var txt = document.createTextNode("Item");  // 创建一个文本节点
        var newLi = document.createElement("li");    // 创建一个元素结点，li元素
        newLi.appendChild(txt);
        var li2 = ul.children.item(1);

        ul.insertBefore(newLi,li2);              // insertBefore（）
        var returnNode = ul.insertBefore(newLi,li2);

        ul.replaceChild(newLi,li2);              //replaceChild();
        var returnNode = ul.replaceChild(newLi,li2);
    })();

    // cloneNode（）   创建节点的拷贝，返回该节点。   传入一个参数。  true深度克隆，克隆该节点和其所有子节点   false只返回该父节点的那一层
    // 拷贝的节点必须要有父节点，如果没有父节点，只能通过appendChild，insertBefore，replaceChild方法对其进行添加

    // normalize（）   合并相邻的Text节点
    (function(){
        var div = document.createElement("div");
        var textNode = document.createTextNode("我是第一个文本");
        div.appendChild(textNode);
        var textNode2 = document.createTextNode("我是第二个文本");
        div.appendChild(textNode2);

        document.body.appendChild(div);

        console.log(div.childNodes.length);             // 输出2
        div.normalize();                                // 将所有文本节点合并    会在源码中直接合并成一个，而不只是显示合并
        console.log(div.childNodes.length);             // 输出2
        console.log(div.firstChild.nodeValue)           // 获取这个合并之后的文本
    })();

    // splitText（）    在指定位置（按字符串下标计算）吧文本节点分割成两个节点   返回新的文本节点
    (function(){
        var div = document.createElement("div");
        var textNode = document.createTextNode("我是第一个文本我是二个文本节点");
        div.appendChild(textNode);
        document.body.appendChild(div);

        var newNode = div.firstChild.splitText(5);    // 会截取  "我是第一个"  前五个字符。  或者说是从0-5但是不包括5
        console.log(div.firstChild.nodeValue);
        console.log(newNode.nodeValue);
        console.log(div.childNodes.length);   // 输出2   被裁成了2个
    })();
</script>


<!------------------------删除节点-------------------------->
<ul id="ul1">
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>
<ul id="ul2">
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>

<script>
    // removeChild（）  删除该对象节点的某个子节点，   必须传入参数，传入需要删除的节点， 返回这个节点
    (function(){
        var ul = document.getElementById('myul');
        console.log(ul.childNodes.length);
        var secondchild = ul.removeChild(ul.childNodes[1]);  // 会删除第一li，因为0号是空白文本节点
        console.log(secondchild);
        console.log(ul.childNodes.length);
    })();
    // removeNode（）   IE私有的， 对象为需要删除的节点。 传入参数false｜true   默认false

    // removeChild（）  和 innerHTML对比
    (function(){
        var div = document.createElement('div');
        console.log(div.parentNode);                                    // div未装载到DOM树，所有浏览器返回null
        document.body.removeChild(document.body.appendChild(div));      // IE6-8会返回文本碎片对象。  保留多了，会产生内存泄漏
        console.log(div.parentNode);
        console.log(div.parentNode.nodeType);

        var ul1 =document.getElementById('ul1');
        document.body.innerHTML = '';        //  获取body元素，然后将其里面的内容都替换成空    innerHTML删除元素是通过替换成空元素来实现
        console.log(ul1.parentNode);        // null
    })();
</script>


<!----------------------------------DOM 属性---------------------------------->
<input type="text" id="txt" aa="bb" xx="bb">
<div url="http://immoc.com" xxx="aaa" yyy="bbb"></div>    // 对于div，url也是一个自定义属性
<script>
    // 属性分为property固有属性  和  attribute自定义属性   自定义属性必须小写，同名的话后面覆盖前面
    // 针对Attribute有getNamedItem();removeNamedItem();;setNamedItem();
    (function(){
        var input = document.getElementById('txt');
        console.log(input.type);   // 固有属性
        console.log(input.id);  // 固有属性
    })();
    (function(){
        var div = document.querySelector('div');
        console.log(input.a);   // 自定义属性 不能通过 点 的方式访问
        console.log(div.attributes.getNamedItem('xxx').nodeValue);   //  attributes先返回指定节点自定义属性的集合，再通过getNamedItem获取指定属性
        console.log(div.attributes['xxx'].nodeValue);  // 也可以通过中括号访问
        console.log(div.attributes.getNamedItem('id').nodeValue);  // 对于固有属性，以id为例，如果div里面id没有写出来，报错。如果给id赋值了，可以访问到
        div.attributes.removeNamedItem('yyy');   // 可以删除自定义属性
        // 创建一个自定义属性
        var attr = document.createAttribute('data-title'); // 创建一个 attribute对象
        attr.value = 'ddd';    //  修改这个attribute的值
        div.attributes.setNamedItem(attr);   // setNamedItem()里面需要穿入一个attribute对象。
    })();
    // 对于固有属性(显式写在标签里面)，可以直接通过 点 访问   但是这个方法不好
    (function(){
        var div = document.querySelector('div');
        div.innerHTML = "属性操作方法";
        console.log(div.innerHTML);
        console.log(div.url);
    })();
    // 访问固有属性和自定义属性的通用方法
    // getAttribute();removeAttribute();;setAttribute();
    (function(){
        var div = document.querySelector('div');
        div.innerHTML = "属性操作方法";
        console.log(div.getAttribute('url'));

        div.setAttribute('xxx','a');    // 已有的属性， set会进行修改    IE7之前不支持setAttribute
        div.setAttribute('data-event','click');    //  没有的属性，set会进行添加

        div.removeAttribute("style");    // remove方法
    })();
</script>

<!-----------------------布尔属性-------------------------->
<input type="checkbox">北京
<input type="checkbox" checked="checked">香港   // 给checked赋值或者不赋值都可以选中，只要穿入的是一个真值也可以，不一定是checked
<input type="checkbox" checked>纽约

<select name="city" id="city" multiple="multiple">
    <option value="北京">北京</option>
    <option value="香港" selected="selected">香港</option>
    <option value="纽约">纽约</option>
</select>

<input id="nationality" type="text" value="中国" readonly="readonly" disabled="disabled" hidden="hidden">

<script>
    (function(){
        // checked
        var inputs = document.querySelector('input');
        inputs[0].checked = true;   //  = 1    = "checked"   ="ss"  =[]  ={}  只要后面是一个真值，会自动转化为true.空数组空集合都是true
                                    //   = 0   = ""    = false  = null 都会转化成false  空对象 null才会是false
        // checked是固有属性，不能通过removeAttirbute移除

        // selected 属性同理
        var city = document.getElementById('city');
        var options = city.options;
        options[2].selected = true;

        // readOnly   只读，不可修改
        var natinality = document.getElementById('natinality');
        natinality.readOnly = false;     // 注意，标签里面的readonly大小写都可以，但是这里访问必须是O大写

        // disabled    不可用， 不仅不可以修改，而且提交表单，这个元素不会被提交。  但是readOnly虽然不可修改，提交表单的时候会提交该元素
        var natinality = document.getElementById('natinality');
        natinality.disabled = false;

        // multiple     是否可以多选，对于选相框
        var city = document.getElementById('city');
        city.multiple = false;

        // hidden    隐藏
        var natinality = document.getElementById('natinality');
        natinality.hidden = false;
    })();
</script>

<!-----------------------字符串属性-------------------------->
<script>
    // 常见字符串属性： id,title,href,src,lang,dir,accesskey,name,value,class
    // W3C全局属性： accesskey,class,contenteditable,dir,hidden,id,lang,spellcheck,style,tabindex,title,translate
    // id： 多个元素取同样的id，getElementById（）只会获取第一个
    // title：  可以通过 点 来获取和修改
    // href：   给<li>传入css。 <li href="style.css">   给<a>添加链接
    // src:    给<script>加入脚本 <script src="domReady.js">   给<img>添加图片<img src="x.jpg">
    // lang    <html lang="zh">
    // dir     文本标签里面， dir="RTL/LTR"  从右向左或者从左向右 书写
    // accesskey   给元素定义一个访问的快捷键。    accesskey="a"   以input为例，设置了<input accesskey="a"> 之后，在页面按alt+a，光标会自动锁定这个input
    // value   上传给服务器的值

</script>

<!-----------------------class属性-------------------------->
<script>
    //  可以多对一，多个属性相同class
    //  classList
    var CL = {
        addClaas:function (elc,cls) {
            ele.classList.add(cls);
        },
        removeClaas:function (elc,cls) {
            ele.classList.remove(cls);
        },
        hashClaas:function (elc,cls) {
            ele.classList.contains(cls);
        },
        toggleClaas:function (elc,cls) {
            ele.classList.toggle(cls);    // 存在就删除，不存在就添加
        }
    };

    var body = document.body;
    console.log(CL.hashClaas(body,'bbb'));
    CL.addClaas(body,'ccc');
    CL.removeClaas(body,'aaa');
    CL.toggleClaas(body,'bbb');
</script>


<!----------------------------------DOM 事件---------------------------------->
    <!--事件句柄：事件处理函数/事件监听函数。事件出发时，执行的函数，操作。-->

    <!-----------------------HTML事件-------------------------->
    <!--事件是文档或浏览器窗口中发生的特定的交互瞬间-->
    <!--HTML事件直接在HTML元素标签内添加事件，执行脚本-->
    <!--语法：<tag 事件="执行脚本"></tag>    执行脚本可以是一个函数的调用-->
<input type="button" value="弹出" onclick="alert('我是按钮')">
    <!--// 鼠标划过按钮的时候，触发mouseverFN函数，       this 指向当前元素的引用-->
<div id="btn" onmouseover="mouseoverFn(this)" onmouseout="mouseoutFn(this,'#f00')" >开始</div>
<script>
    function mouseoverFn(btn) {
        // 鼠标移动 按钮背景改为红色
        btn.style.background = "#f00";
    }
    function mouseoutFn(btn,bgcolor) {
        // 鼠标移开 按钮背景改为蓝色
        btn.style.background = bgcolor;
    }
</script>

    <!-----------------------DOM 0级事件-------------------------->
    <!--    0级只能绑定一个事件，一个元素绑定多个事件，只会执行最后一个。  2级事件可以绑定多个监听函数-->
    <!--    通过DOM获取HTML元素，   元素.事件=执行脚本   在DOM上绑定事件，执行脚本可以是一个匿名函数，也可以是一个函数的调用-->
    <style>
        .lock{width: 140px;height: 30px;line-height: 30px;background: #1a5acd;color: #cccccc;}
        .unlock{width: 140px;height: 30px;line-height: 30px;background: #666666;color: #cccccc;}
    </style>
    <div class="lock" id="lockbtn">锁定</div>
    <script>
        // 获取按钮
        var lockbtn = document.getElementById('lockbtn');
        // 给按钮绑定时间，this是对当前DOM元素的引用
        lockbtn.onclick=function () {
            if(this.cacheName=="lock"){
                // 通过修改class值，改变引用的css样式
                this.className="unlock";
                // 通过innerHTML修改这个div内部的元素，内部只有一个文本元素
                this.innerHTML="已解锁";
            }else{
                this.className="lock";
                this.innerHTML="锁定";
            }
        }
        // 注意，调用自定义函数的时候，给DOM元素赋值事件，后面的函数不要加括号，加括号的话，刷新页面会自动调用
        function clickbutton(){

        }
        lockbtn.onclick = clickbutton;   // 这里函数后面不要加括号。  加括号会自动触发，不用点击按钮
    </script>


<!-----------------------常用的鼠标键盘时间-------------------------->
onload: 页面加载时触发    对象是固定window。   window.onload=function(){ }
onclick：鼠标点击
onmouseover：鼠标滑过
onmouseout：鼠标离开
onfocus：获取焦点    只能用于input标签为text，password的元素，还有textarea标签。
onblur：失去焦点
onchange：域内容发生变化   用于下拉菜单或者单选框多选框

onsubmit:   表单中确认按钮被点击   虽然是点击按钮提交，但是不是加在按钮上，而是加在表单上
onmousedown:  在元素上鼠标按下按钮   onmousedown和onmouseup加起来等于onclick
onmousemove:  鼠标指针移动    鼠标在作用对象内移动才算
onmouseup:  在元素上松开鼠标按钮
onresize:  调整浏览器窗口大小
onscroll:  拖动滚动条   整个页面滚动，就绑定在body，某个元素自己的滚动条就绑定这个元素。  div的overflow="scroll/auto"，则绑定这个div

对同一个对象设置 onmousedown， onmousemove，  onmouseup这三个事件，可以实现拖动元素的时候发生什么。
<style>
    .box{padding:50px;}
    .left,.tip{float:left;}
    .left{margin-right: 10px;}
    .tip{display: none;font-size: 14px;}
</style>

<script>
    window.onload=function () {
        // 获取文本框和提示框
        var phone=document.getElementById("phone"),
            tip = document.getElementById("tip");
        phone.onfocus=function(){
            tip.style.display='block';
        }
        phone.onblur=function(){
            // 获取表单内容 即input里面用户输入的内容
            var phoneVal=this.value;
            // 检测长度11位，    isNaN（）检测是否是数字
            if(phoneVal.length==11 && isNaN(phoneVal)==false){
                console.log("ok");
                //  修改提示内容为一个对号图片。    要修改html元素内的东西，就用innerHTML   可以插入标签等内容
                tip.innerHTML='<img src="../images/example/logo.png">';
            }else{
                console.log("error");
                tip.innerHTML='<img src="../images/example/logo.png">';
            }
        }

    }

</script>

<div class="box">
    <div class="left">
        <input type="text" id="phone" placeholder="请输入手机号">
    </div>
    <div class="tip" id="tip">
        请输入有效的手机号
    </div>
</div>

<script>
    window.onload=init;
    function init(){
        var menu = document.getElementById("menu");
        // onchange一般用于select或checkbox或radio
        menu.onchange=function(){
            var bgcolor = this.value;
            // 也可以通过select的option集合来访问
            // var bgcolor = menu.options[menu.selectedIndex].value;
            if(bgcolor=="") return;
            document.body.style.background=bgcolor;
        }
    }
</script>

<div class="box">
    请选择您喜欢的颜色
    <select name="" id="menu">
        <option value="">请选择</option>
        <option value="#f00">红色</option>
        <option value="#0f0">绿色</option>
        <option value="#00f">蓝色</option>
    </select>
</div>

onkeydown：用户下一个键盘按键时触发
onkeypress：按下时发生（只响应数字和字母，符号）
onkeyup：键盘按键松开时
keyCode：返回onkeypress、onkeydown或onkeyup事件触发的健的字符代码，或键的代码
<script>
    // event代表时间的状态 如触发event对象的元素，鼠标位置及状态等
    // 在事件触发的function里，用一个参数接受事件对象
    document.onkeydown=function (event) {
        console.log(event.keyCode);
    }
</script>
<style>
    .text span{font-weight: bold;color:#f00;}

</style>
<div>
    <p class="text">您还可以输入 <span><em id="count">30</em></span>/30</p>
    <div class="input">
        <textarea name="" id="text" cols="70" rows="4"></textarea>
    </div>
</div>
<script>
    var text = document.getElementById("text");
    var total=30;
    var count = document.getElementById("count");
    document.onkeyup=function () {
        // 每次按下按钮都检查textarea内字数
        var len=text.value.length;
        var allow = total - len;
        count.innerHTML=allow;
    }
</script>

    <!-----------------------DOM 2级事件-------------------------->
    <!--    高级事件处理方式，一个事件可以绑定多个监听器    通过addEventListener函数绑定事件-->
<div id="parent">
    <div class="child" id="child">点击我</div>
</div>
<ul>
    <li>item1</li>
    <li>item2</li>
    <li>item3</li>
</ul>

<a href="http://www.baidu.com" id="egforprevent">跳转链接</a>

<div id="gaodu">测试event.clientY，  event.pageY，  event.screenY</div>
<style>
    #gaodu{
        height: 2000px;
        background: lightgreen;
    }
</style>

<script>

    // addEventListener(); 添加事件
    var btn2 = document.getElementById("btn2");
    btn2.addEventListener('click',function () {},false);   // 第三个值可以不填，默认false
    btn2.addEventListener('mousedown',function () {},false);   // 可以绑定两个，且都会执行


    // removeElementListener():   移除事件
        element.removeEventListener(event,function,useCapture);    //  event必须，要移除事件的名称，function必须，移除的函数，useCapture可选，布尔，移除事件句柄的阶段
        btn2.addEventListener('click',function () {},false);
        btn2.removeEventListener('click',function () {},false);  // 这样并不会解绑上一个监听器。 因为第二个参数，是匿名函数，两个并不相等，必须定义函数名

        // IE8 及 IE8 以下浏览器独特的。
        // attachEvent():  添加事件   其他浏览器都是 addEventListener()；
        //     element.attachEvent(event,function)；   其中event前面必须加上"on"前缀
        // detachEvent():  移除事件
        //     element.detachEvent(event,function);

    // 事件周期
    // 解释器窗前一个event对象后，会按照如下三个阶段将其在HTML元素间进行传播
    // 1、事件捕获：事件对象沿DOM树从上往下传播  2、目标触发：运行事件监听函数   3、事件冒泡：事件对象沿DOM树从下往上传播

    // 事件冒泡  儿子节点和父亲节点都绑定了事件，child的执行之后，会继续往上沿 直系亲属树结构进行冒泡作用。
    // 先执行child里面的，再执行parent的事件       child -> parent -> body -> html
    document.getElementById("parent").addEventListener("click",function (e) {
        alert("parent事件被触发，"+this.id);
    })
    document.getElementById("child").addEventListener("click",function (e) {
        alert("child事件被触发，"+this.id);
    })

    // 事件捕获   儿子节点和父亲节点都绑定了事件，不管哪个元素的事件被执行，都会从根部html往下执行。   大部分采用事件冒泡
    // html ->body -> parent -> child
    // 修改为事件捕获的方式，只需要在 addEventListener();  第三个参数useCapture设置为true，就可以

    // 事件委托   原理是事件冒泡
    // 想给上面ul下面的所有li添加绑定时间，可以每个li设置一个id然后每个li单独绑定。 很不好
    // 直接给ul绑定时间，所有li都会触发   
    var ul = document.getElementById("ul");
    ul.addEventListener("click",function (event) {
        if(event.target.id == "one"){
            alert(1)
        }else if (event.target.id == "two"){
            alert(2)
        }
    });

    <!--   Event对象属性与方法   -->
    // type属性
    var mybtn = document.getElementById("mybtn");

    mybtn.addEventListener("click",function (event) {
        alert(event.type);   // 输出click
    })
    mybtn.addEventListener("mouseout",function () {
        alert(event.type);  // 输出mouseout    鼠标移出元素
    })
    // 作用， 更多的时候对于同一个元素我们需要的函数基本通用，但是对于不同的交互又有区别。 就可以写一个通用函数，根据event.type判断操作的类型，然后执行操作
    var eventFunction = function(event){
        alert("eventFunction run")
        if(event.type == "click"){

        }else if(event.type == "mouseout"){

        }
    }
    mybtn.addEventListener("click",eventFunction);
    mybtn.addEventListener("mouseout",eventFunction);

    // target /  currentTarget
    var parent = document.getElementById("parent");
    parent.addEventListener("click",function (event) {

        // 点击儿子，时间是在父亲上面   因为只有儿子才展示出来，可以点击到。并且根据冒泡规则，也是执行儿子
        // target就是点击谁谁就是target。  事件源。
        console.log(event.target);   // 会输出 <div class="child" id="child">点击我</div>
        // currentTarget 事件绑定在谁身上，就指向谁
        console.log(event.currentTarget);  // 会输出整个 div parent 包括儿子
    })

    // event.preventDefault  阻止默认行为
    var a = document.getElementById("egforprevent");
    a.addEventListener("click",function (event) {
        event.preventDefault();   //  加了这一句，就会阻止默认的行为，只执行绑定事件
        alert("元素本身默认行为（跳转链接）以及绑定事件都会执行");
    })

    // event.stopPropagation()   阻止事件冒泡或捕获
    var parent = document.getElementById("parent");
    parent.addEventListener("click",function () {
        alert("parent");
    })
    child.addEventListener("click",function (event) {
        alert("child");
        event.stopPropagation();    // 本身执行完child会冒泡，执行parent，加入阻止冒泡之后，只执行child，不执行parent及以后的事件了
    })

    // event.clientY，  event.pageY，  event.screenY
    // clientY 浏览器顶部底边到鼠标位置（滚动不会影响）
    // pageY 浏览器顶部底边到鼠标的位置（滚动之后的距离也计算在内）
    // screenY 屏幕顶部到鼠标的位置
    var gaodu = document.getElementById("gaodu");
    gaodu.addEventListener("click",function (event) {
        alert("clientY:" +  event.clientY + "; pageY:" + event.pageY + "; screenY:" +  event.screenY);
    })

    // 对于IE8及以下。
    event.returnValue = false;  // 等于 preventDefault
    event.cancelBubble = true;  // 等于 stopPropagation
    srcElement;                 // 等于 target
    type;                       // 等于 type

    // 跨浏览器兼容性写法
    var EventUtil = {
        // 绑定事件
        addHandler: function(element,type,handler){
            if(element.addEventListener){
                element.addEventListener(type, handler, false);
            }else if(element.attachEvent){
                element.attachEvent("on" + type , handler);
            }else{
                element["on" + type] = null;
            }
        },
        // 移除事件
        removeHandler: function (element,type,handler) {
            if(element.removeEventListener){
                element.removeEventListener(type, handler, false);
            }else if(element.detachEvent){
                element.detachEvent("on" + type , handler);
            }else{
                element["on" + type] = null;
            }
        },
        // 获取目标
        getTarget: function (event) {
            return event.target || event.srcElement;
        },
        // 阻止默认事件
        preventDefault: function(event) {
            if(event.preventDefault){
                event.preventDefault();
            }else{
                event.returnValue = false;
            }
        },
        // 阻止事件冒泡
        stopPropagation: function(event) {
            if(event.stopPropagation){
                event.stopPropagation();
            }else{
                event.cancelBubble = true;
            }
        }
    }
    // 自己封装的EventUtil的使用示范
    var child = document.getElementById("child");
    EventUtil.addHandler(child,"click",function (event) {
        var target = EventUtil.getTarget(event);
        console.log(target);
    })



    // 常用事件类型

    // load: 页面加载时触发    对象是window或者img或者script或者css                addEventListener("load",function (event)）
    // 正常加载图片   创建一个img标签元素
    var image = document.createElement("img");
    image.addEventListener("load",function (event) {
        alert("图片加载完毕")；
    })
    image.src = "smile.jpg";
    // 图片预加载    先创一个image对象，把图片加载并存在内存中。  当打开页面的时候直接从内存调用
    var image = new Image();
    image.addEventListener("load",function (event) {
        alert("图片加载完成");
    });
    image.src = "smile.jpg"
    // js动态加载
    var scrpit = document.createElement("script");
    EventUtil.addHandler((script,"load",function(event){
        alert("js Loaded");
    });
    script.src = "jquery.js";
    document.body.appendChild(script);
    // css动态加载
    var link = document.createElement("link");
    link.type = "text/css";
    linke.rel = "stylesheet";
    EventUtil.addHandler(link,"load",function (event) {
        alert("css loaded");
    });
    link.href = "example.css"
    document.getElementsByTagName("head")[0].appendChild(link);

    // unload  从一个页面切换到另外一个页面
    window.addEventListener("unload",function (event) {
        alert("Unloaded");
    })

    // resize:  调整浏览器窗口大小
    // scroll:  拖动滚动条   触发频率很高 整个页面滚动，就绑定在body，某个元素自己的滚动条就绑定这个元素。  div的overflow="scroll/auto"，则绑定这个div
    // blur     失去焦点
    // focus：  获取焦点  不支持冒泡
    // click：  鼠标点击     click = mousedown + mouseup
    // dblclick：  鼠标双击
    // mousedown： 鼠标按下
    // mouseup：   鼠标松开
    // mousemove： 鼠标在元素上移动     触发频率很高
    // mouseout：  鼠标从元素移开  离开目标元素或其子元素都会触发。  父元素绑定，从子元素移动到父元素也算。
    // mouseover： 鼠标从元素外进入元素
    // mouseenter： 等于mouseover
    // mouseleave： 等于mouseout  只能是离开目标元素。    父元素绑定，从子元素移到父元素是不算的

    // 鼠标点击，同时按下相应按键，event会多了相应的属性
    EventUtil.addHandler(div,"click",function (event) {
        var keys = new Array();
        if(event.shiftKey){
            keys.push("shift");
        }
        // 同理还有 ctrlKey, altKey, metaKey
    })
    // event.button == 0   鼠标左键
    // event.button == 1   鼠标中键
    // event.button == 2   鼠标右键


    // 按键事件
    // keydown  按下任意键触发
    var myText = document.getElementById("myText");
    EventUtil.addHandler(myText,"keydown",function (event) {
        console.log(event.keyCode);   //  输出对应键码
    })
    // keyup    按键弹起触发
    // keypress 按下字符键。   仅限字符键   且尽量不用keyCode，某些浏览器报错，  用charCode
    // textInput
    EventUtil.addHandler(myText,"textInput",function (event) {
        console.log(event.data);   //  输入什么内容，event.data就会是什么
    })
    // DOMNodeRemoved   从元素中任意元素被删除时就会触发
    EventUtil.addHandler(document,"DOMNodeRemoved",function (event) {
        console.log("删除节点成功");
    })
    document.body.removeChild(myText);
    //     <ul id="myUl">
    //          <li>item1</li>
    //          <li>item2</li>
    //          <li>item3</li>
    //     </ul>
    var myUl = document.getElementById("myUl");
    var li = document.getElementById("myUl").childNodes[1];   // 注意 0 号是空白节点
    EventUtil.addHandler(myUl,"DOMNodeRemoved",function (event) {
        console.log("删除节点成功");
    })
    myUl.removeChild(li);
    // DOMNodeRemovedFromDocument   元素移除之前就触发
    // DOMNodeInserted     元素被添加时触发
    // DOMSubtreeModified  DOM结构中任何变化都会触发
    // DOMNodeInsertedIntoDocument   元素被添加之前触发
    // DOMContentLoaded   DOM树加载完就会触发    不管图像，js，css文件或其他资源。    load 是所有这些加载完
    // haschange    一定给window添加，且注意c不大写。  页面地址#之后的值发生改变的时候触发。  包含event.oldURL和event.newURL。分别是修改前和修改后的地址

    // 移动端事件
    // <meta name="viewport" content="width=device-width, initial-scale=1.0">     meta是写在head标签里面
    // <button id="mybtn">点击我</button>

    var mybtn = document.getElementById("mybtn");
    //  touchstart  手指触摸屏幕就会触发
    EventUtil.addHandler(mybtn,"touchstart",function () {
        console.log("当前触摸屏幕的触摸点数组：" + event.touched);                  // 几个手指触控到了，都会包含
        console.log("数组中只包含引起事件的触摸点信息：" + event.changedTouches);    // 触控到的手指中 移动的那几个手指
        console.log("只包含放在元素上的触摸信息：" +event.targetTouches);           // 触摸到屏幕的手指，且在附加了事件的元素上的手指才会被记录
    });
    //  touchmove  手指在屏幕上滑动时触发
    EventUtil.addHandler(mybtn,"touchmove",function () {
        console.log("");
    });
    // touchend  手指移开屏幕时触发
    EventUtil.addHandler(mybtn,"touchend",function () {
        console.log("");
    });
    // touchcancel  系统停止跟踪触摸时触发


    // 小项目，点击对应颜色按钮，页面变成对应颜色。
    // <ul id="ul">
    //     <li>红色</li>
    //     <li>黑色</li>
    //     <li>黄色</li>
    // </ul>
    var ul = document.getElementById("ul");
    var canvas = document.getElementById("canvas");
    ul.addEventListener("click",function (e) {
        var that = e.target;
        console.log(that);
        if(that.innerHTML == "红色"){
            canvas.style.background = "red";
        }else if(that.innerHTML == "黑色"){
            canvas.style.background = "black";
        }else if(that.innerHTML == "黄色"){
            canvas.style.background = "yellow";
        }
    })
</script>



    <!-----------------------BOM -------------------------->

<script>
    // BOM（browser object model）浏览器对象模型
    // BOM对象包含有： window，navigator，screen，history，location，document，event

    // window对象：既是javascript访问浏览器窗口的一个接口，又是ECMAscript中规定的全局对象
    var age = 15;
    // 声明一个全局变量
    window.age = 15;

    function sayAge(){

    }
    sayAge();
    // 声明一个全局方法
    window.sayAge = function(){

    }
    window.sayAge();

    window.alert();      // 弹出一个带有指定消息  和 确认 的对话框
    window.confirm();    //  弹出一个一个对话框，有指定消息，确认及取消选项。
                         // 点击确认，confirm()  返回true， 点击取消， confirm（）返回false。  需要设置一个变量存储返回值
    var btn = document.getElementById("btn");
    btn.onclick=function () {
        var result = window.confirm("您确认要删除吗？")
        if(result) {
            document.getElementById("box").style.display="none";    // 隐藏box这个节点
        }
    }
    window.prompt("text, defaultTex");    // text对话框中显示的纯文本，不能是HTML文本。 defaultText默认输入文本
                                          // 返回值：取消返回null，确认返回输入的text，没输入就会返回defaultText。
    window.open(pageURl,name,parameters);  // 打开一个新的浏览器窗口或者查找一个已命名的窗口。
                                           // pageURL子窗口路径 name子窗口句柄（声明新窗口的名称，方便后期引用） parameters窗口参数（各参数逗号隔开）
    window.onload = function () {
        window.open("newwindow.html","newwindow","width=400,height=200,left=0，toolbar=no,status=no");
    }       // width,height,left(X轴坐标),top（Y轴）,toolbar（是否显示工具栏）,menubar（是否显示菜单）,scrollbars（是否显示滚动条）,
            // location（是否显示地址字段）,status（是否添加状态栏）   是否显示，值为no/yes。不是true/false
    window.close();  // 关闭窗口
        var quit = document.getElementById("quit");
        quit.onclick = function () { window.close() }

    // 定时器
    // 超时调用
    setTimeout(code,millisec);   // 在指定毫秒数之后调用函数或者计算表达式   code要调用的函数或js代码   millisec毫秒数
        setTimeout(function () {   },2000);  // 会返回一个id值，是该超时调用的id值，用于取消
        var timeout1 = setTimeout(function () {   },2000);
        clearTimeout(timeout1);
    clearTimeout();      // 传入超时调用任务的id值
    // 间歇调用
    setInterval(code,millisec)    // 每隔一定时间调用一次代码   同样也会返回一个id，用于清除这个间歇调用
        var intervalID = setInterval(function () {
            console.log("每两秒调用一次");
        },2000);
        setTimeout(function () {
            clearInterval(intervalID);
        },10000);   // 10秒之后清除这个间歇调用，不会继续打印了
        // 也可以通过循环变量取消
        var num = 1,  max = 10,  timer=null;
        timer=setInterval(function () {
            nums ++;
            if(num > max){
                clearInterval(timer);
            }
        },2000);
        // 可以循环嵌套使用  例如用setTimeout去实现setInterval
        function inCreamentNum(){
            console.log(num);
            num ++;
            if(num <= max){
                setTimeout(inCreamentNum,1000);
            }else{
                clearTimeout(timer);
            }
        }
        timer = setTimeout(inCreamentNum,1000);

    // location对象： 提供与当前窗口加载文档相关的信息，还有导航功能。  既是window的属性，也是document的属性
    location.href;    // 指向，并能返回当前页面完整的URL，   location.href = window.location.href;
    location.hash;    // 指向，并能返回URL中的hash（# 后跟0或者多个字符），如果不包含则返回空字符   #  后面可以跟一个元素的id，来定位某个元素达到跳转的目的
        //     <div class="box1" id="top"></div>
        //     <div class="box2"></div>
        //     <input type="button" id="btn" value="返回顶部">
        var btn = document.getElementById("btn");
        btn.onclick=function () {
            location.hash="#top";       // 点击按钮的时候，location.hash变为 top这个div的id。 页面会自动跳转到这个div的位置。
        }
    location.host;       // 返回服务器的名称和端口号
    location.hostname;   //返回不带端口号的服务器名称
    location.pathname;   // 返回URL的目录或文件名
    location.port;       // 返回URL中指定的端口号，若没有返回空字符串
    location.protocol;   // 返回页面使用的协议
    location.search;     // 返回URL的查询字符串，这个字符串以问号开头
    // 通过位置操作，改变浏览器位置的方法
        // 1。直接改变location的一些属性
        location.href;    // location.href="index.html"   等同于  window.location="index.html"  会在浏览器中生成历史记录
        location.hash;
        location.search;
        // 2。location的方法
        location.replace(url);    // 使用replace不会在历史记录中生成新纪录
        location.reload();        // 重新加载当前显示的页面， 不传参数，有可能从缓存中加载，刷新。   传入true，会从服务器重新加载   建议放到js代码的最后

    // history对象： 保存用户在浏览器中访问页面的历史记录
    history.back();    // 回到历史记录的上一步，相当于history.go(-1);
    history.go(index);  // 跳转到历史记录的某一个页面。   go（-2） 是回到两个页面之前。  但是必须是，0->1->2,可以从2回到0，  如果0直接到2，就不能
    history.forward();   // 回到历史记录的下一步，相当于history.go(1);   必须是先通过链接从0->1，然后1->0,此时才可以forward从0->1

    // screen对象：  包含有关客户端显示屏相关的信息
    screen.availHeight;  // 返回可用屏幕的高度  （不包含任务栏）
    screen.availWidth;   // 返回可用屏幕的宽度
    window.innerHeight;  // 窗口的内宽高。   还有outerHeight和outerWidth
    window.innerWidth;

    // navigator：  包含浏览器的信息。浏览器类型，设备是移动还是pc
    navigator.userAgent;   // 返回浏览器的名称，版本，引擎，操作系统等信息。通常加入toLowercase，便于获取数据。
        // 检测浏览器类型
        function getBrowser() {
            var explorer = navigator.userAgent.toLowerCase(),browser;
            // 浏览器信息中含有字符，有的话就会 > -1
            if(explorer.indexOf("chrome") > -1){
                browser = "Chrome浏览器";
            }else if(explorer.indexOf("msie") > -1){
                browser = "IE浏览器";
            }
        }
        var explorer = getBrowser();
        alert("您当前使用的是："+explorer);
</script>



<script>
    // ----------变量类型-----------
    // 基本类型： 4 'str' true undefined null
    // 引用类型： []数组  {}对象
    // 基本类型，不可被修改，赋值只是覆盖。引用类型，可被修改。
    // 基本类型不可设置属性值，如：var person = 'xiao'     person.name = 'hhh'  错误
    // 引用类型可以设置属性值  如：var person = {}    person.name = 'hhh'  person.family=['mother','father']可以
    // typeOf 4;   typeOf(4);   两种写法都可以
    // instanceof 用于堆引用类型检查父类，不可用于基本类型     console.log([] instanceof Array)数组是Array.   [] {}都是Object


    // ----------内存-----------
    // 内存 = 堆内存（有序，不可扩容） + 栈内存（无序，可扩容）
    // 堆内存：有序，每个空间大小固定，不可扩容，存储基本类型，   存储了栈内存中内容的地址
    // 栈内存：无序，每个空间大小可扩容，存储引用类型。    然后把地址存放在堆内存（地址大小固定），通过地址去调用引用类型

    // ----------相等比较-----------
    // 基本类型
    var xmScore = 4;
    var xhScore = 4;
    console.log(xmScore == xhScore);    // 直接比较
    // 引用类型
    var xm = {
        age: 18,
        score: 4
    };
    var xh = {
        age: 18,
        score: 4
    };
    console.log(xm == xh);    // false 引用类型地址不一样，不能相等。  除非是引用相等
    var xh = xm;
    console.log(xm == xh);   //  true  二者引用相等
    xh.score++;     // 引用相等，是同一个东西，通过任何一个引用去改变值，都会影响
    // 引用类型，可以通过自定义方法，比较他们的每一个属性值是否相等
    function copyObj(obj) {
        var newObj = [];
        for (var p in obj) {
            newObj = obj[p];
        }
        return newObj;
    }

    // ----------变量 和 作用域-----------
    // name 和 fn都是全局作用。 可以直接在全局空间调用
    var name = "xm";

    function fn(argument) {
        // sex 和 fn2 都是作用在这个局部空间
        var sex = 'male';

        function fn2(argument) {
            var age = 18;
        }
    }

    // 所有全局的属性和方法，都是全局这个对象window的属性和方法
    window.fn == fn;
    window.name == name;

    var person = {}
    person.name = 'xm';
    // 除了直接访问对象的属性进行修改，还可以用with。但是尽量不要使用
    with (person) {
        name = 'xm';
    }

    // ----------JS解析机制-----------
    // 先 预解析，再 逐行解读代码
    var name = 'xm';
    var age = 18;

    function fn(argument) {
        console.log(name);
        var name = 'xh';
        var age = 10;
    }

    fn();     // 打印 undefined
    // 解析过程
    // 1.预解析
    window
    // 先解析所有全局下的var 声明，都会赋值为undefined。
    name = undefined;
    age = undefined;
    sex = undefined;
    // window下所有进行var定义过了，但是未赋值的变量，都会赋值undefined
    // 对于函数只会拿过来，并不运行，也不解读
    function fn(argument) {
        console.log(name);
        var name = 'xh';
        var age = 10;
    }

    // 预解析完window，开始预解析全局下的function
    fn
    name = undefined；
    age = undefined;
    // 同样所有未赋值的变量，都会赋值undefined
    // if () for ()代码块中定义的函数，无法预解析。  尽量不要这样做
    // 举例一
    console.log(a);  // 打印出undefined
    var a = 1;     // 预解析之后，a=undefined，然后开始打印，打印出undefined之后，在对a进行赋值，a=1

    console.log(a);   // 会报错
    a = 1;     // 预解析不会解析到a，因为a没有var。   先打印，无法找到这个变量，就会报错
    // 举例二
    console.log(a);     // a()
    var a = 1;
    console.log(a);    // 1
    function a() {
        console.log(2);
    }
    console.log(a);
    var a = 3;
    console.log(a);     // 3
    function a() {
        console.log(4);
    }
    console.log(a);     // 3
    a();     // error
    // 先预解析var，a=undefined，再解析function，发现重名，且有两个重名，就会用function覆盖变量，且最后一个会覆盖前一个。此时a是一个function
    // 然后运行。第一次打印，就是打印a这个function。第二句把a重新赋值成了1，打印1。 然后赋值3，打印3，最后运行a(),可是此时a是一个变量3，无法运行
    // 举例三
    var a = 1;
    function fn(){
        console.log(a);   // 1
        a = 2;
    }
    fn();
    console.log(a);    // 2
    // 先预解析了全局变量a=undefined。 然后预解析fn。 但是fn里面什么都没有定义。
    // 执行，全局变量a=1，然后运行fn，fn开始打印a，自己里面找不到a（连undefined都没有，根本没定义a，所以才会找全局变量。），
    // 所以就输出全局变量。 然后把全局变量修改成2。 继续打印全局变量2
    var a = 1;
    function fn(a){    // 传入的参数相当于var定义局部变量，会参与函数预解析
        console.log(a);   // undefined
        a = 2;    // 局部变量
    }
    fn();
    console.log(a);    // 1

    var a = 1;
    function fn(a){     // 传入一个参数 1
        console.log(a);   // 1     打印传入的参数
        a = 2;    // 局部变量修改成2
        console.log(a);   // 2
    }
    fn(a);     // 传入a   此函数仅仅只是起到打印参数的作用。 没有修改参数
    console.log(a);    // 1


    // ----------JS对象-----------
    // 对象可以直接花括号创建，只是相当于数据的集合
    var cat = {
        'name' : 'Tome',
        'speak':function () {

        },
        'friend':{
            'name':'Jerry',
            'age':4
        }
    }
    // 赋值 读取
    cat.name = 'Tim';       // console.log(cat.name)
    cat['name'] = 'Time';
    cat.type = '加菲猫';    // 附加新值
    // 删除
    delete cat.type;
    console.log(cat.type);  // undefined
    // 是否有属性   in
    console.log('name' in cat);
    // 遍历属性
    for(var p in cat){
        console.log(p);        // 输出每一个属性  name   speak friend  没有引号
        console.log(cat[p]);   // 获取属性值的正确方法
        console.log(cat.p);    // （有疑问。 下面这两个没明白）  cat.name可以输出可是这个cat.p就不能输出了
        console.log(cat['p']);
    }

    // ----------JS函数-----------
    // 函数也是个对象，可以给他添加属性，也可以添加方法
    function add(num1, num2){
        return num1 + num2;
    }
    add.sex = 'male';
    add.setSex = function(sex){
        this.sex = sex;
    }
    console.log(add.sex);                // male
    console.log(add.setSex('female'));   // undefined
    console.log(add.sex);                // female
    console.log(add(1,2));
    // 函数是对象，就可以赋值给变量。
    var add = function fn(){ return 1}
    // 赋值之后可以通过变量名访问函数本体，  变量名+（）  可以运行函数。
    console.log(add());         // 1
    console.log(add);           // ƒ fn(){ return 1}
    // 但是原来的函数名就无法调用（无法在外部调用），会报错。  所以通常这种赋值了的，我们就把函数名去掉。   但是，可以在fn里面调用fn
    console.log(fn());         // 报错
    console.log(fn);
    // 函数和其他对象一样可以放到数组中，也可以选择不用命名，通过数组下标访问,调用
    list = [{cat:'tom',age:'18'},function (){return 1}]
    console.log(list[1]);     // ƒ (){return 1}
    console.log(list[1]());   // 1
    // 函数可以作为一个数据值。赋值给对象。 如上面的cat对象
    var cat = {
        'name' : 'Tome',
        'speak':function () {

        },
    }
    // 函数可以作为参数，传入另外的函数
    setTimeout(function () {
        console.log(1);       //  加了括号立马执行
    },1000)

    setTimeout(fn,1000);       // 不加括号是只传入函数名，根据setTimeout函数，fn会过1秒之后执行，
    function fn() {
        console.log(1);
    }
    // 函数也可以作为返回值
    function fn() {
        return function () {
            console.log(1);
        }
    }
    var newFn = fn();
    newFn();   // 可以把返回的函数赋值给一个变量，在调用
    fn()();     // 也可以直接（）（），表示运行fn（）的到的函数

    // 函数定义三种方式
    // 1 直接定义函数
    function add(){

    }
    // 2 定义函数赋值给变量
    var add = function () {   // 这里function可以写名字，但是这个名字只能在这个函数本身之内调用，无法在外部通过这个名字调用

    };
    // 3 构造函数
    var add = new Function('num1','num2','return num1 + num2;');   // 构造实例，浪费资源，然后函数体较长不易于编写
    add();      //  构造函数里面必须穿入字符串
    // 方式2，3  在预解析过程中，不会生成函数。  必须在定义后调用。  但是方式1，在预解析就会生成，可以先写调用函数语句，再写函数，也不会出错。

    // 函数调用
    // 内层可以调用外层，调用同级。  外层无法调用内层
    var operation = {
        add:function(num1,num2){
            return num1 + num2;
        },
        subtract: function (num1,num2) {
            return num1 - num2;
        }
    }
    operation.add(1,1);   // 方法相当于特殊属性，可以通过类似获取属性的方式调用

    document.onclick = function () {   // js一些事件的函数，是浏览器自动调用了
        console.log("点击了");
    }
    document.onclick();    // 我们也可以手动调用。

    var operation = {
        '@': function () {

        },
        key : function () {

        }
    }
    console.log(operation.add(1,2));
    console.log(operation['@'](1,2));    // 对于不合法的字符，不能直接作为函数命名，但是可以加上引号，作为方法名，然后通过方括号调用
    var key = 'add';
    console.log(operation[key](1,2));  // 方括号可以调用字符串命名的函数，点 却不行。

    // 构造函数的调用
    // 普通函数，没有返回值会返回undefined
    var num = add();    // add没有返回值的话，num = undefined
    var obj = new Person();   // 通常构造函数首字母大写，不是必须。   构造函数必须new， 一定返回一个对象
    // 内置的还有  new Object；   new Array

    // 间接调用   call   apply
    var name = 'xm';
    var person = {};
    person.name = 'hh';
    person.getName = function () {
        return this.name;
    }
    console.log(person.getName());   // hh     正常调用函数，输出person的name属性。
    console.log(person.getName().call(window));  //  xm     call传入第一个参数，是改变函数内部this的指向。  这里指向window，  xm是window下的name属性
    console.log(person.getName().apply(window));  //  xm  只设置一个参数的apply间接调用和只设置一个参数的 call调用一样

    function add(num1 ,num2){
        return num1 + num2;
    }
    console.log(add(1,2));
    console.log(add.call(window,1,2));   // 3    call的后面参数是需要传入函数的参数，逐个写出来。    函数中没有this，所以第一个参数写什么都无所谓
    console.log(add.apply(window,[1,2]));  // 3    apply后面第二个参数是一个数组，将需要传入函数的参数作为数组传入
    var dat = [1,2];
    console.log(add.apply(window,dat));  // 3   直接传入一个数组变量。   在需要调用其他对象的方法，或者通过其他函数得到的结果直接传入当前函数，特别方便
    // 可以使当前函数调用别的对象的函数或者属性值


    // 可选参数
    //  当传入的 参数数量 < 形参数量   未传入的参数自动赋值为undefined
    //  想让一个函数传入参数可选，可以添加判断
    function pow(base,power) {
        // 可以 用if判断power是否存在
        if(!power)  power = 2;    // 当传入的参数不存在，自动让power=2，相当于求平方
        // 也可以 看power是否存在，存在｜｜就传入第一个真等于power， 不存在就为假，｜｜返回第一个真，即2
        power = power || 2;   //
        return Math.pow(base,power);
    }
    // 实参 > 形参   用arguments，   arguments每个函数都有，局部，是个类数组对象，不能用array的push等方法，函数传入的所有参数都会保存在arguments这个数组中
    function add(){
        if(arguments.length == 0)   return;
        var sum = 0;
        for(var i = 0; i < arguments.length; i++){
            sum += arguments[i];
        }
        return sum;
    }
    console.log(add(1,2,3,4,5,6));
    // var arguments{    // arguments的结构就是一个对象，而不是数组，他的变量刚好是0，1，2。。。然后就可以类似数组通过方括号访问
    //     '1' : 2,
    //     '2' : 3,
    // }

    // 用对象做参数
    function setPerson(obj){
        var person = {};
        person.name = obj.name || 'xh';
        person.sex = obj.sex || 'male';
    }



    // ----------面向对象-----------
    // 基于原型的面向对象方式中，对象Object是依靠构造器constructor利用原型prototype构造出来的
    // 所有函数都有一个prototype属性，该属性引用一个对象，即原型对象
    function fn() {   // 自定义函数

    }
    alert(fn.prototype);   // Object    对象    fn.prototype -----> 内存地址 ------> 存储一个对象
    alert(fn.prototype instanceof Object); // true    object 是js中所有对象的父对象
    // 构造函数对象：  函数构造器 创造函数对象 ，（效率低）     前面都是正常变量，functionBody是自定义的函数体。
    var obj = new function (var1,var2,var3...., functionBody);

    // 闭包： 一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数）
    // 函数内部var声明的都是局部变量，省去var就是全局变量。   函数内可以访问全局变量，函数外不可访问这个函数的局部变量
    // 闭包特点：函数b是在a内嵌套的，函数a需要返回函数b
    // 用途：1，读取函数内部的变量（例如下面例子中的i）    2，让i变量的值保留在内存中
    function a() {
        var i = 0;
        alert("a执行了")
        function b() {
            alert(++i);
        }
        return b;        // 这里只返回b，没有执行b
    }
    var c = a();      // a（）是运行了a，然后返回b给了c，所以c就相当于b了
    c();

    function a() {
        function b() {
            return 999;
        }
        return b();        // 跟上面不一样，这里返回的时候执行了b，相当于返回function b的返回值，即999
    }
    var c = a();      // a（）是运行了a，c接受a（）的返回值，即b（），同时b（）也运行了，c就是接受b（）的返回值，即999
    alert(c);    // 999
    // 让变量保存在内存中
    function f1() {
        var n = 999;
        nAdd = function () {    // 这里没有var  定义的是全局变量
            n = n +1;
        }
        s=777;                  // 函数内定义的不要var，函数或者变量都作为全局变量。  但是必须在父函数调用之后才可以
        function f2() {
            alert(n);
        }
        return f2;
    }
    alert(s);    //  报错  此时f1没有运行过，所以，s是不存在的，没定义
    var rs = f1();
    alert(s);    // 运行了f1之后，s出现了，且作为全局变量。 一直存在内存中。
    rs();       //  999   相当于执行f2
    nAdd();     // 执行了   nAdd是一个全局变量，f1执行后，就可以在全局调用
    rs();       // 1000   注意，此时执行过了nAdd，n加了1。  就说明，n作为函数的局部变量，一直存在内存中，f1是f2的父函数，n就相当于f2的全局变量，可以被f2调用
    alert(n);   // 报错   但是总体来看n毕竟局部变量，只是相对于f2是全局，然后f2可以调用。不能通过其他函数 或者 直接调用

    // 闭包优缺点：优点：有利于封装，可以访问局部变量（重要）    缺点：内存占用浪费严重，可能造成内存泄漏

    // 声明对象的方式
    // 1。字面式
    var person = {
        name : "zhangsan",
        eat : function(food) {
            alert("我在吃"+ food);
        }
    }
    alert(person.name);
    person.eat("面条");
    alert(person instanceof Object);   // true  一切对象都是Object的子类
    // 2。new操作符后跟Object构造函数  再通过 点 操作符进行赋值
    var person = new Object();
    person.name = "zhangsan";
    person.eat = function(food) {
        alert("我在吃"+ food);
    }
    // 3。js中的构造方法声明对象
    function person(name,food){    // 创建一个person的构造函数
        this.name = name;
        this.eat = function() {
            alert(this.name + "在吃"+ food);   // 构造函数里调用参数，必须用this
        }
    }
    var obj1 = new person("zhangsan","面条");    // 实例化这个对象，然后就可以使用
    alert(obj1.name);
    obj1.eat();
    var obj2 = new person("lisi","饭");   // 可以创造很多很多这个对象
    // 4。工厂模式    注意跟上面的构造方法区别。  两者很像
    function creatPerson(name,food){    // 创建一个person的构造函数 注意跟上面一种的区别
        var person = new Object()    // 区别一，在构造函数中创建了一个实例，所以在外部创建的时候，不需要new
        person.name = name;        // 对函数内创建的对象进行属性赋值
        person.eat = function() {
            alert(this.name + "在吃"+ food);   // 构造函数里调用参数，必须用this
        }
        return person;          // 区别二： 必须返回这个对象。
    }
    var obj1 = creatPerson("zhangsan","面条");    // 函数内创造了实例对象并返回，所以在外部只需要接受这个方法的返回值就可以
    alert(obj1.name);
    obj1.eat();
    // 5。js中原型模式声明对象
    // 原型模式根本：函数本身声明为空内容，利用prototype定义一些属性及方法。
    // 优点：让所有实例化的对象都拥有它包含的属性及方法
    function person() {       // 声明一个空对象

    }
    alert(person.prototype instanceof Object)    // 所有函数都含有prototype这个属性。  且这个prototype也是一个对象。  只有函数才有。 普通对象，变量没有
    person.prototype.name = "zhangsan";     // 通过prototype原型对这个对象进行属性赋值
    person.prototype.eat = function(food) {
        alert(this.name + "在吃"+ food);    // 注意赋值方法的时候，也是用this调用本身的属性值，这个this是指prototype。
    }
    // 上面用 点 的方法进行赋值，相当于下面的操作，对person内包含的prototype这个对象赋值。
    // person.prototype={
    //     name : "zhangsan",
    //     eat : function(food) {
    //         alert(this.name + "在吃"+ food);
    //     }
    // }
    var obj = new person();       // 需要new实力话一个对象，因为方法里面没有创建实例
    alert(obj.name);
    obj.eat("面条");     // 该方法需要传入参数
    // 6。js中混合模式   构造模式 + 原型模式
    function person(name){        // 对于对象本身属性，采用构造模式传入参数
        this.name = name;
    }
    person.prototype.eat = function(food) {   // 对于对象的方法，采用原型模式，赋值
        alert(this.name + "在吃"+ food);
    }
    var obj = new person("张三");
    alert(obj.name);
    obj.eat("面条");           //
    obj.prototype.eat("粉丝");  // 两种都可以成功调用方法

    // 对象的存储
    // 内存分四个部分 数据段 + 栈内存 + 堆内存 + 代码段
    // 栈内存存储对象的地址 person的地址
    // 堆内存存对象的属性，注意不包括函数的具体代码     person.mame="zhangsan"    person.eat   （存函数名，不存代码）
    // 代码段存储函数的具体代码   function（）{alert(this.name + "在吃"+ food);}

    // js通过闭包实现封装
    //
    function demo() {
        var n = 1;   // 局部变量，在方法外部不能直接访问
        function test() {   // 外部调用的出口
            return ++ n;
        }
        return test;
    }
    var at = demo();
    alert(at());
    // 另一种
    function A() {
        var t = 3;
        function _xx() {
            alert(11 + "***");
        }
        this.xx = function () {
            return _xx;
        }
    }
    A.prototype = {
        oth:function () {
            alert("普通方法");
        }
    }
    var a = new A();
    var b = a.xx();   // a.xx() -----> function _xx()
    b();
    //缺陷：占内存 不利于继承

    // 原型和原型链
    // 原型：利用prototype添加属性的方法
    // 原型链：js在创建对象的时候，都有一个_proto_的内置属性，用于指向创建它的函数对象的原型对象prototype

    // js继承
    var person = function () {};  // 这相当于是一个构造函数
    person.prototype.name = "zhangsan";
    var p = new person();    // 用构造函数创建一个对象  分为三个阶段
    // 1. var p = {};
    // 2. p.__proto__ = person.prototype         __proto__ 是所有对象自带的属性（也是对象）      prototype 函数自带的对象（其他变量，对象没有）
    // 3. 创建对象（初始化对象）p         ------》  相当于调用 person.call(p)
    alert(person.prototype instanceof Object);   // true
    alert(p.__proto__ instanceof Object);     // true
    alert(p.__proto__ = person.prototype);    // true
    alert(p.name);    // p是一个对象，他里面没有name属性，但是有自带的__proto__，所以就去p.__proto__找name，而p.__proto__ = person.prototype。
    alert(p.__proto__.name);    // 先找p.__proto__.name   p.__proto__也没有name，就去与他相等的 person.prototype 去找name
    alert(person.prototype.name);  // 最后在 person.prototype 找到了name属性。     __proto__ 就相当于指针，从一个实例对象，找到构造这个实例对象的构造函数的原型
    // 再看看函数继承
    var person = function () {};
    person.prototype.say = function () {
        alert("今天天气很好");
    }
    var p = new person();
    p.say();    // p没有say方法的        就去 p.__proto__找say，而p.__proto__ = person.prototype
    // 更复杂一点
    var person = function () {};
    person.prototype.say = function () {
        alert("今天天气很好");
    }
    person.prototype.salary = 5000;
    var progammer = function () {}
    progammer.prototype = new person();
    progammer.prototype.wcd = function () {
        alert("明天天气也不错");
    }
    progammer.prototype.salary = 10000;

    var p = new progammer();    // p.__proto__ = programmer.prototype = new person()    可以想像一个临时中间对象。 var p1 = new person()； programmer.prototype=p1
    p.say();   // 可以调用      p.say(); --> p.__proto__ --> programmer.prototype --> p1 ---> p1._proto__ --> person.prototype --> 找到了say
    p.wcd();   // 也可以调用  p.wcd(); --> p._proto__ --> programmer.prototype --> 找到了wcd执行
    alert(p.salary);  // 10000  p.salary --> p._proto__ --> programmer.prototype --> 找到了salary，所以不会继续往下面找。
    // 再看一个原型继承
    function person(name,age){     // 这个是父类，构造函数，普通人对象。
        this.name = name;    // 这里添加的属性值，是通关传参进来的，   person.prototype.name   是不存在的
        this.age = age;
    }
    person.prototype.sayHello = function () {   // 方法需要采用prototype进行赋值
        alert("属性值" + this.name);
    }
    var per = new person("zhangsan",20);
    per.sayHello();

    function student() {};
    student.prototype = new person("lisi",18);    // 原型继承  子类
    student.prototype.grade = 3;      // 子类不光继承了父类的属性方法，自己还可以添加属性，方法
    student.prototype.study = function () {
        alert(this.grade);
    }
    var s = new student();
    s.sayHello();
    alert(s.grade);
    alert(s.name);     // 这个name，是找到student.prototype = new person("lisi",18); 这个new person 相当于一个中间对象，这个中间对象有name属性，所以结束了。 并不会找到最上面person的name


    // 关键词
    // instancepf  变量是否是对象的实例
    // delete  删除对象的属性
    function fun() {
        this.name = "zhangsan";
        thos.say = function () {
            alert(this.name);
        }
    }
    var obj = new fun();
    delete obj.name;   // 可以删除属性值 不能删除原型链重的属性和变量）
    delete obj.say();  // 错误  不能删除方法 不能删除变量
    var demo = "lisyt";
    delete demo;      // 错误 不能删除变量
    // call apply
    function add(a,b){
        alert(a + b);
    }
    function subs(a,b){
        alert(a - b);
    }
    add.call(subs,5,3);   // 8     用add替换subs，  相当于 add(5,3)
    var ac = {};          // 其实subs的位置只是一个引用，可以用任何以及存在的变量去替代.
    add.call(ac,5,3);     // 8     也是相当于 add(5,3)   意思是，add这个方法对ac使用。
    add.apply(ac,[5,3]);  // 8     apply和call一样的，只不过参数是通过数组传入

    function animal() {
        this.name = "animal";
        this.showName = function () {
            alert(this.name);
        }
    }
    function cat() {
        this.name = "cat";
    }
    var an = new animal();
    var c = new cat();
    an.showName.call(c,"hhhhhh");  // cat    an.showName 是一个函数，然后对于c调用这个函数。而showName是输出 this.name。 此时this指向c的name，就是cat
    // callee： 返回正在执行的function对象，function内容   callee是arguments的一个属性，默认值是正在执行的函数对象，callee就是指代函数本身
    function demo() {
        alert(11);
        alert(arguments.callee);   // callee当作属性，函数的内容    arguments是函数自带的属性
        alert(arguments.callee());  // 报错：因为陷入死循环。   callee()  确实是继续执行这个函数本身，但是么有函数终止条件
    }
    demo();
    // 加入函数终止条件，利用callee写成一个递归函数
    var sum = function(){
        if(n < 1){
            return 1;
        }else{
            return n+arguments.callee(n-1);    // 在函数内部调用此函数
        }
    }
    alert(sum(5));
    // arguments  每个函数都有一个Arguments对象的实例arguments，引用函数的参数（实参）
    // 可以用数组下标的方式引用arguments元素
    // arguments.length   参数个数   arguments.calllee引用函数本身
    function test(a,b,c) {
        alert(arguments.length);     // 3
        alert(arguments[1]);    // 2 访问1号元素。   这种下标访问，可以遍历参数
        alert(arguments.callee);  // 输出整个函数
    }
    test(1,2,3);
    // this:
    // this函数调用，在函数内部定义属性/变量
    function test(){
        this.x = 1;
        alert(this.x);
    }
    test();
    // 修改全局变量               用得很少
    var x = 1;
    function test(){
        this.x = 0;     // 这里修改了全局变量
        alert(this.x);
    }
    test();   // 0  运行test（），修改了全局变量x
    alert(x); // 0  全局变量已经被修改

    var name = 2222;
    function student(name){
        this.name = name;
        alert(this.name);
    }
    function teacher(name){
        this.name = name;
        alert(this.name);
    }
    student("hh"); // hh
    teacher("ttt"); // ttt
    alert(name);   // ttt  最终name被修改为 ttt
    // this作为方法的调用，构造函数内，this指当前对象。   用得最多
    function student(name){
        this.name = name;    // 相当于指 t.name
    }
    var t = new student("zhangsan");
    alert(t.name);
    // this在call apply中第一个参数
    var x = 0;       // 全局变量x=0
    function test() {
        alert(this.x);
    }
    var o = {};
    o.x = 1;
    o.m = test;
    o.m.apply();  // 0   apply没有传入参数，o.m = test     test.apply()  相当于直接调用test，此时this.x指的就是全局变量x
    o.m.apply(o); // 1   apply传入参数o，   o.m = test   test.apply(o) 等于对对象o运用test方法， 此时this.x指向当前对象，及 o的x属性值

    // 对象冒充
    function person(name,age) {
        this.name = name;           // 这里面定义的都是特权属性和特权方法
        this.age = age;
        this.sayHi = function() {
            alert("hi");
        }
    }
    person.prototype.walk = function () {  // 利用原型定义的方法，是person.prototype的，所以不属于特权方法。  是共有的方法和属性
        alert("walk");
    }
    function student(name,age,grade) {   // 继承父类的方式： 原型继承  构造继承  call  apply
        this.newMethod = person;   // 冒充person对象，传递特权属性和特权方法给子类
        this.newMethod(name,age);
        this.grade = grade;
    }
    var s1 = new student("zhangsan",15,5);   // s1是student对象，继承了person，拥有person所有的特权属性和特权方法
    alert(s1.name);  // 运行
    s1.sayHi();    // 运行
    s1.walk();   // 报错   walk不是person的特权属性。

    // 构造函数的继承 ：在子类内部构造父类的对象，实现继承
    function parents(name) {
        this.name = name;
        this.say = function () {
            alert("parent 的name是" + this.name);
        }
    }
    function child(name,age) {    // 继承parent
        this.pObj = parents;   // 在子类中设置一个pObj这个属性，这个属性值是parents这个函数 然后调用这个函数。
        this.pObj(name);       // 子对象的参数name传递到父对象中   为什么要用this.pObj.   这是保证，parents这个函数的对象，是当前的child对象。
        console.log(this.pObj);  // 输出parents这个函数
        // 以上传递可以用call实现。    注意一定是要对当前的child对象使用parents构造函数
        // pObj = parents;
        // pObj.call(this,name);
        this.age = age;
        this.sayC = function () {
            alert("child:" + this.name +"---"+"age:" + this.age);    // 这里的this.name是父对象的name
        }
    }
    var p = new parents("zhangsan");
    p.say();   // zhangsan
    var c = new child("lisi",18);
    c.sayC();  // lisi
    c.say();  // lisi   可以调用父类的方法



    function person(name,age,len){
        this.name = name;
        this.age = age;
        this.len = len;
        this.say = function () {
            alert(this.name + ":" + this.age + ":" + this.len);
        }
    }
    // call 继承
    function student(name,age) {
        person.call(this,name,age);      // this 指当前的student对象。  对当前的student运用person这个构造函数。
    }
    var per = new person("zhangsan",25,"170");
    per.say();
    var stu = new student("lisi",18);
    stu.say();   // lisi 18 undefined

    // ----------JS正则表达式-----------
    // 字面量 或 直接量
    /js/   // 匹配js这两个字符   这种方式简单，但是无法修改/。 用得较多
    // 构造函数
    new RegExp();       // 这种方式。在需要修改正则表达式时用得多。  可以让用户传入一个string，然后修改构造函数第一个参数。

    // test  和  exec
    var str = "I love js";
    var pattern = /js/;
    alert(pattern.test(str));   // 是否匹配到，返回true｜false
    alert(pattern.exec(str));   // 匹配到的，就存在一个数组中返回   找不到返回null
    // 模式修饰符    可以组合  /js/igm
    // i = ignoreCase （忽视大小写）   g = global（全局匹配）    m = multiline（多行匹配）
    var str = "I love Js";
    var pattern = /js/i;     //  模式修饰符直接写在最后。
    // var pattern = RegExp('js','igm');   // 正则表达式的构造函数第一个参数是表达式，第二个参数是模式修饰符
    alert(pattern.test(str));   // true
    alert(pattern.exec(str));   // 返回大写的Js  返回的是原字符串中匹配到的

    // 转义字符 \
    var str = "//我是注释";
    // pattern 里面的特殊字符需要加入转义符
    var pattern = /\/\//;
    console.log(pattern.exec(str));

    var str = "//我是注释";
    // pattern 里面的特殊字符需要加入转义符
    var pattern = /\/\//;
    console.log(pattern.exec(str));
    // string 中的特殊字符也需要加入转义符。  "\\\\" --> 代表两个 "\\"
    var str = '\\\\';
    var pattern = /\\\\/;
    console.log(pattern.exec(str));   // 匹配到两个
    // 我们从网页获取来的文本，如果有换行，会出现\n，虽然网页不显示。
    var str = '1.html\n2.css\n3.js';
    // 匹配换行符
    var pattern = /\n/;
    // 也可以用16进制的ASCII码来匹配这种特殊字符
    var pattern = /\x0A/;


    var str = 'javascript';
    // 匹配到s，  []表示匹配括号里面任意一个字符，匹配到一个，这整个括号就过了。  从str里面，一个个的看，j没有，a没有，v没有，a没有，s有，匹配返回
    var pattern = /[slpedfd]/;
    console.log(pattern.exec(str));
    // 匹配到a， ^ 代表取反，除了后面这几个，其他可以匹配
    var pattern =/[^js]/;
    console.log(pattern.exec(str));
    // [a-z]  [c-c]  [c-d]  [0-9]   [a-zA-Z0-9] (不能写a-Z)   [c-b](报错，前面必须比后面一个小)  [\u4e00-\u9fa5](中文编码，可以匹配这两个编码范围内的汉字)
    // [^\n] (除了换行符以外所有字符)   /./ (除了换行符以外所有字符)
    // /\w/=[a-zA-Z0-9_] (大小写字母，数字，下划线)   /\W/=[^a-zA-Z0-9_]
    // /\d/=[0-9] (数字)   /\D/=[^0-9]
    // /\s/  空格和制表符    /\n/ 换行   /\t/ 制表符
    // /\d{2}/ 匹配两个数字   /\d{1,3}/ 大于等于1个小于等于3个   /\d{1,}/ 大于等于1个，至少一个    /\d{,3}/ 错误写法
    // /\d?/ = /\d{0,1}/ 零个或一个      /\d+/=/\d{1,}/ 一个以上         /\d*/=/\d{0,}/ 零个以上

    // 贪婪匹配
    var str = 'aaa';
    var pattern = /a+/;
    // 虽然 a+ 表示一个以上，但是都是默认尽可能多的匹配。 所以会匹配3个a。
    // /a+?/ 后面加一个问好表示切换为非贪婪匹配。只匹配最少的，1个a。    /a*?/  /a??/ 同理
    var str = 'aaab';
    var pattern = /a+?b/;
    // 这个最后并不会匹配 ab，而是aaab。因为切换为非贪婪是需要在条件允许的情况下。优先获取第一个匹配到的。  这里第一个a匹配上了，然后/a+b/满足一直匹配完。 而不会放弃前两个a，直接找最后的ab
    // 举例应用
    var str = '<td><p>a</p></td><td><p>b</p></td>';
    // 我们只想匹配第一个td下面的内容，。 这个pattern是贪婪的，会匹配到两个td
    var pattern = /<td>.*<\/td>/;
    // 修改成非贪婪的，只会匹配第一个td，即包含a那个
    var pattern = /<td>.*?<\/td>/;

    // 分组和引用
    var str = 'abab';
    // 只能匹配到ab。  + 只影响到前面一个字符
    var pattern = /ab+/;
    // 匹配到abab
    var pattern = /(ab)+/;
    // 返回一个数组['abc','ab']   数组第一个是整个正则表达式匹配到的内容，第二个是括号里部分匹配到的内容。  括号是一个捕获性的分组，单独拿出来
    var pattern = /(ab)c/;
    // 修改成非捕获性，不会单独返回括号匹配到的
    var pattern = /(?:ab)c/;
    // 嵌套捕获性的括号  从左边开始看哪个括号最先，就先返回   返回['abc','abc','bc','c']
    var pattern = /(a(b(c)))/;

    var str = 'ab cd ab cd';
    // 反斜杠加数字，可以代表第一个，第二个分组。   这里可以返回 ab cd ab cd
    var pattern = /(ab) (cd) \1 \2/;

    var str = '<p><a>这是一段文字</a></p>';
    // 想匹配外层的标签。 然后需要额外返回里面的内容
    // <([a-zA-Z]+)> 匹配了任意标签头，但是结尾还这样写，可能匹配到其他的标签尾，所以可以用上面的捕获性括号的引用<\/\1>。
    // 然后返回中间内容，就把中间任意表达内容的正则表达式扩起来(.*?)
    var pattern = /<([a-zA-Z]+)>(.*?)<\/\1>/;

    // 首匹配  /^js/  必须以js开头。   区别/[^js]/   这个是匹配一个字符，除了js以外的都可以
    // 尾匹配  /js$/  必须以js结尾
    // 应用举例
    var str = '1a2a8d8896a9d';
    // 相匹配一个全都是数字，不允许出现其他字符。   可以加上首尾匹配，表明必须以数字开头，数字结尾，中间全都是数字
    var pattern = /^\d+$/;
    // 可以用  /\D/  达到同样的效果。   /\D/表示匹配除了数字以外的， 如果匹配到了，就错误，如果匹配不到，就表明全是数字

    // /\bjs/   匹配单词的边界    'js html'  '@@js@@'  边界包括单词之间的空格和换行还有特殊字符
    // 应用举例
    // 写在前面：   千万注意 获取元素的时候 getElements  和 getElement， 前者返回的是一个数组需要取出来单个元素，后者直接返回的这个元素
    // 通常 Id获取的是element，  className，tagName都是elements.   对于取出了elements之后，返回的类数组，需要通过[]取出来，才可以找childNodes
    // <section id="section" class="section">
    //     <div class="  odd23 odd odd2">1</div>
    //     <div class="even">2</div>
    // </section>
    // <footer>
    //     <div class="odd">3</div>
    //     <div class="even">4</div>
    // </footer>
    // 可以采用byClassName获取到section，但是返回的是一个list，需要取出第一个元素
    // var parentNodeList = document.getElementsByClassName('section');
    // var parentNode = parentNodeList[0];
    // 可以采用byId直接获取到section，这样返回的就是section这个元素
    var parentNode = document.getElementById('section');
    var oddP = getByClassName('odd',parentNode);
    var evenP = getByClassName('even',parentNode);

    for(var i = 0; i < oddP.length; i++){
        oddP[i].style.backgroundColor = 'red';
    }
    for(var i = 0; i < oddP.length; i++){
        evenP[i].style.backgroundColor = 'yellow';
    }
    // IE不兼容classname匹配，写出一个兼容所有浏览器的byclass的方法
    function getByClassName(className,parentNode) {
        if(document.getElementsByClassNam){
            console.log('存在getclass方法');
            return document.getElementsByClassName(className);
        }else {
            parentNode = parentNode || document;
            var nodeList = [];
            var allNodes = parentNode.getElementsByTagName('*');
            var pattern = new RegExp('(\\b)'+ className + '(\\b)');
            // 也可以采用下面的pattern， className顶头或者前面有空格，className作为结尾或者后面有空格。 即需要匹配的classname是在开头或者结尾或者中间
            // var pattern = new RegExp('(^|\\s)'+ className + '($|\\s)');
            for(var i = 0; i < allNodes.length; i++){
                if (pattern.test(allNodes[i].className)){
                    // 最初的方案，直接看classname是否相等，但是这只适用于元素的classname只有一个参数，对于多个参数的classname必须用正则匹配
                    // if(allNodes[i].className == className){
                    nodeList.push(allNodes[i]);
                }
            }
        }
        return nodeList;
    }

    // 前瞻性匹配
    var str = 'javascript';
    // 匹配的还是java，但是必须java后面是script才匹配到
    var pattern = /java(?=script)/;
    // 匹配的还是java，但是必须java后面不是script才匹配到
    var pattern = /java(?!script)/;

    // pattern的其他实例方法  pattern.lastIndex
    // 通常情况下，pattern匹配到了第一个就返回。   pattern = /js/g； 后面g表示全局匹配。 会匹配完整个字符
    var str = 'js js js';
    var pattern = /js/g;
    console.log(pattern.exec(str));  // js   index是0  第一个js  pattern.lastIndex = 3
    console.log(pattern.exec(str));  // js   index是3  第二个js  pattern.lastIndex = 6
    console.log(pattern.exec(str));  // js   index是6  第三个js  pattern.lastIndex = 9
    console.log(pattern.exec(str));  // null                    pattern.lastIndex = 0
    console.log(pattern.exec(str));  // js   index是0  第一个js
    // 非全局匹配情况下，lastIndex一直是0，全局匹配下，每次匹配到一个lastIndex都会加1，等到匹配完了，才会又回到0
    // test和exec类似，只是匹配到了返回true，  所以前三个为true，第三个匹配不到返回false，第四个又是true
    var str = 'js js js';
    var pattern = /js/g;
    var total = 0, match = '', result;
    while((result = pattern.exec(str) != null)){
        total ++;
        match += '第' + total + '个匹配到的是：' + result[0] + '，他的位置是：' + result.index + '\n';
    }
    console.log(str);
    console.log(match);

    var pattern = new RegExp('a\\n\b');
    console.log(pattern.toString());      // /a\nb/
    console.log(pattern.valueOf() == pattern);   // valueOf 返回的是他自己本身
    var pattern = new RegExp('\\b','ig');
    console.log(pattern.ignoreCase);   // true    有忽略大小写
    console.log(pattern.global);       // true   有加全局匹配
    console.log(pattern.multiline);    // false  未选择多行匹配
    console.log(pattern.source);       // \b    返回转译后的正则表达式，即实际想匹配的字符
    console.log(pattern.lastIndex);    // 非全局匹配下，一直是0。   全局匹配的时候，会增加
    // 构造函数属性
    var pattern = /(j)s/;
    console.log(RegExp.input);    // 在执行  pattern.exec(str);  的时候填充，返回 str
    console.log(RegExp.$_);    // 等于  RegExp.input
    console.log(RegExp['$_']);  // 等于  RegExp.input
    console.log(RegExp.lastMatch);  // 上一个匹配到的
    console.log(RegExp['$&']);  // 等于 RegExp.lastMatch   不能用 .$&  因为&是不合法字符，需要用方括号
    console.log(RegExp.leftContext);  // 匹配了一个之后，用这个命令可以返回左边的文本
    console.log(RegExp['$`']);  // 等于  leftContext
    console.log(RegExp.rightContext);  // 匹配了一个之后，用这个命令可以返回右边的文本
    console.log(RegExp["$'"]);  // 等于  RegExp.rightContext
    console.log(RegExp.lastParen);  // 上一个匹配到的子选项
    console.log(RegExp["$+"]);  // 等于  RegExp.lastParen
    console.log(RegExp.$1);  // $1-$9  返回对应序号的分组  与前面讲的   var pattern = /(ab) (cd) \1 \2/;    \1 一样的意思
    // 注意，没有分组的时候 $0 表示这个整个正则匹配到的   有分组 ，才有子匹配，才用$1-$9

    // string对象中与正则相关的方法
    var str = 'html js';
    var pattern = /(j)s/g;
    console.log(str.search(pattern));    // pattern 有没有g全局匹配，都是一样的，返回第一个匹配到的字符
    console.log(str.match(pattern));    // 非全局匹配的时候 和exec一样的效果。  可以添加分组，返回分组里面的内容
    // 全局匹配的时候  会把所有pattern找出来，放在一个数组。   exec是分开几个数组。    且match不会返回分组里的内容

    // 多行匹配m  必须跟g配合使用  且跟首尾匹配相配合才有效果
    var str = '1.js\n2.js\n3.js';
    var pattern = /js$/gm;
    console.log(str.match(pattern));   // 不要m，会把整个str当作一行，尾匹配，到最后一个js。  加了m，每一行都会有一次尾匹配。  就会返回三个js

    // 分隔符 split    要不要全局匹配都一样
    var str = 'html,  js  , css';
    console.log(str.match('\s*,\s*'));       // 在, 处分割     两边可以多个空格
    var pattern = /s*,s*/;
    console.log(str.match(pattern));   // 在, 处分割两边可以多个空格

    // replace
    var str = 'I love js js';
    console.log(str.replace('js','html'));   // 只会匹配到第一个，替换
    var pattern = /js/g;
    console.log(str.replace(pattern,'html'));   // 全局匹配到，然后都替换
    var pattern = /(js)/;
    document.write(str.replace(pattern,'<strong style="color:red;">$1</strong>'));    // 可以用$1 去指代匹配到的分组，当作替换内容。
    // 在网页上将js加粗,修改颜色为红色
    var str = "中国军队和阿扁一起办证";
    var pattern = /国军｜阿扁｜办证/g;
    console.log(str.replace(pattern,'*'));   //  这样不管匹配到的内容是几个字，都只出现一个 *
    console.log(str.replace(pattern,function ($0) {     // 没有分组， $0 就表示整个正则匹配到的。  如果/(国)军/  这样$0指代'国军'，$1指代'国'
        console.log($0);
        var result = '';
        for(var i = 0; i < $0.length; i ++){
            result += '*'
        }
        return result;              // 第二个参数是这个匿名函数返回的 字符串。   匹配到的 $0 多长，就给几个*
    }))


    // 案例
    // 1.qq号   全是数字 首尾不为0  最少五位 最多11位
    var pattern  = /^[1-9]\d{4,10}$/;
    // 2.昵称   2-18位，中英文，下划线，数字
    var pattern  = /^[\u4e00-\u9fa5a-zA-Z0-9_]{2,18}$/;
    var pattern  = /^[\u4e00-\u9fa5\w]{2,18}$/
    // 3.密码   6-16位，区分大小写，不能用空格等空白字符
    var pattern  = /^\S{6-16}$/;         // \s空白字符  \S非空白字符
    var pattern  = /^[\w~!@#$%^\[\]]{6,16}$/;   // 穷举法，一些网站内部就是这么写的
    // 4.去除首尾的空白字符
    var str = '      Alex   ';
    var pattern = /^\s+|\s+$/g;    // 或者首匹配或者尾匹配  ｜  表示 或者
    var pattern1 = /^\s+/g;
    var pattern2 = /\s+$/g;
    console.log(str.replace(pattern1,'').replace(pattern2,''));   // 匹配两次 正则表达式简单方便理解，也可以提高效率
    // 5.转驼峰
    var str = 'background-color';
    var pattern = /-([a-z])/gi;
    console.log(str.replace(pattern,function (all,letter) {
        return letter.toUpperCase();
    }));
    // 解释：
    var str = 'background-color';
    var pattern = /-[a-z]/gi;              // 先看不要分组括号。
    console.log(pattern.exec(str));        // ["-c", index: 10, input: "background-color", groups: undefined]
    console.log(str.replace(pattern,function (a,b,c) {
        console.log(a);                    // -c
        console.log(b);                    // 10
        console.log(c);                    // background-color
        return c.toUpperCase();
    }));
    var str = 'background-color';
    var pattern = /-([a-z])/gi;            // 加上分组括号。
    console.log(pattern.exec(str));        // ["-c", "c", index: 10, input: "background-color", groups: undefined]
    console.log(str.replace(pattern,function (a,b,c) {
        console.log(a);                    // -c
        console.log(b);                    // c
        console.log(c);                    // 10
        return c.toUpperCase();
    }));
    // 所以，可以看出，虽然转驼峰操作中，匿名函数传入的参数，是相当于pattern先进性exec操作，得到的list，里面的元素按照顺序传入这个匿名函数中执行
    // 6.匹配HTML标签
    var str = '<p class="odd" id="odd">123</p>';
    var pattern = /<\/?[a-zA-Z]+(\s+[a-zA-Z]+=".*")*>/g;  // ["<p class="odd" id="odd">", "</p>"]
    var pattern = /<(?:[^"']|"[^"]*"|'[^']*')*>/g;        // ["<p class="odd" id="odd">123</p>"]
    var pattern = /<(?:[^"'>]|(["'])[^"']*\1)*>/g;        // ["<p class="odd" id="odd">", "</p>"]
    console.log(str.match(pattern));
    // 7.邮箱     alex_1@yahoo.com.cn
    var str = '<p class="odd" id="odd">123</p>';      // 先全部分块分组，写完之后，不需要分组的，去掉括号，需要分组但不需要捕获的，加上 ?:
    var pattern = /(?:\w+\.)*\w+@(?:\w+\.)+[a-z]/i;   // /()*()@()+()/i  --->   /(\w+\.)*(\w+)@(\w+\.)+([a-z])/i  --->  /(?:\w+\.)*\w+@(?:\w+\.)+[a-z]/i
    var pattern = /^[a-z0-9]+(?:[._-][a-z0-9]+)*@[a-z0-9]+(?:[._-][a-z0-9]+)*\.[a-z]{2,4}$/i;   //  /()()*@()()\.()/i  ---->  /([a-z0-9]+)([._-][a-z0-9]+)*@([a-z0-9]+)([._-][a-z0-9]+)*\.([a-z]{2,4})/i -----> /^[a-z0-9]+(?:[._-][a-z0-9]+)*@[a-z0-9]+(?:[._-][a-z0-9]+)*\.[a-z]{2,4}$/i
    // 8.URL 地址  (协议:\/\/)主机名(:端口号)/(路径)
    // 粗略版本
    var parttern = /^(https?:\/\/)?([^:\/])(:\d+)?(\/.*)?$/       // /^()?()()()$/ ---> /^(https?:\/\/)?([^:\/])(:\d+)?(\/.*)?


    // 正则表达式总结
    // 1.用途
    //    a.查找特定字符  exec（）  test（）  match（）  search（）
    //    b.替换文本（eg：敏感词过滤）
    //    c.数据有效性验证
    // 2.创建正则表达式
    //    a.字面量或直接量：/js/igm
    //    b.构造函数： new RegExp('js','igm');  new RegExp(变量,'igm');
    // 3.模式修饰符
    //    a. g--全局匹配  match：只有非全局匹配才会返回分组中匹配到的内容；全局匹配只会一次返回所有匹配到的字符
    //                   replace：非全局匹配，只替换第一个匹配到的内容；全局匹配替换所有匹配到的内容
    //    b. m--多行匹配  需要跟全局匹配，首尾匹配配合
    //    c. i--忽略大小写
    // 4.简单的转义字符
    //    a.\n 换行符
    //    b.\t 制表符
    //    c.\xnn由十六进制数nn指定的拉丁字符（eg.\x0A<=>\n）
    //    d.\uxxxx由十六进制数xxxx指定的Unicode字符（eg.\u0009<=>\t）
    // 5.字符类
    //    a.[...]方括号内的任意一个字符（[^...]除去方括号内所有字符的任意字符）
    //    b. . 除换行符以外的任意字符
    //    c. \w任何字母、数字以及下划线组成的一个字符（\W除了任何字母数字下划线）
    //    d. \d任何一个数字（\D除了所有数字）
    //    e. \s任何Unicode空白符（eg.空格、制表符、\n）
    // 6.重复（量词）  默认贪婪匹配，尽可能多的匹配
    //    a.{n,m} n <= x <= m
    //    b.{n,}  x >= n
    //    c.{n}   x = n
    //    d.?     {0,1}
    //    e.+     {1,}
    //    f.*     {0,}
    // 7.非贪婪匹配   尽可能少的匹配
    //    a.{n,m}?
    //    b.{n,}?
    //    c.{n}?
    //    d.??
    //    e.+?
    //    f.*?
    // 8.选择、分组和引用
    //    a. | 选择，匹配该符号左边或右边的东西
    //    b. (...)分组，统一操作；捕获括号中的内容；
    //    c. (?:...) 非捕获分组 （不会单独返回分组里的内容）
    //    d. \n 第n个捕获性分组的引用（eg:\1\2\3...）
    // 9.捕获到的内容
    //    a. exec返回的数组中
    //    b. /\1/模式中
    //    c. replace的第二个参数中  $1  ($0表示整个正则匹配到的内容)
    //    d. RegExp.$1
    // 10.指定匹配位置
    //    a. ^首匹配
    //    b. $尾匹配
    //    c.\b和\B单词边界，即\w和\W之间的位置
    //    d.(?=p)和(?!p)前瞻性匹配，只有接下来的字符=p，才匹配之前的内容
    // 11. RegExp对象的实例方法
    //    a. test(字符串)
    //    b. exec(字符串)
    //    c. toString()、toLocaleString()、valueOf()
    // 12. RegExp对象的实例属性
    //    a. global是否设置了g
    //    b. ignoreCase是否设置了i
    //    c. multiline是否设置了m
    //    d. source字面量形式对应的字符串
    //    e. lastIndex开始搜索下一个匹配项的字符位置，默认0
    // 13. RegExp对象的构造函数属性
    //    a. input匹配的字符串
    //    b. lastMatch最近一次的匹配项
    //    c. lastParen最近一次匹配的捕获组
    //    d. leftContext字符串中匹配到的内容之前的文本
    //    e. rightContext字符串中匹配到的内容之后的文本
    //    f. $1-$9 第1-第9个匹配到的捕获组的引用
    // 14. String对象和正则表达式相关的方法
    //    a. search(正则或字符串)
    //    b. match(正则)
    //    c. split(正则或字符串)
    //    d. replace(正则或字符串，替换成的文本或函数)





</script>




</body>
</html>