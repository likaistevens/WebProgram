<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CSS样式</title>
<!--  嵌入标签  CSS格式 选择器 {属性：值}  置于style标签内，且放在head标签内-->
    <style type="text/css">
        p{font-size:30px;
            color:blue;
            font-family: Arial}
        /*多个选择器用同一种样式，可以选择器之间逗号隔开*/
        h1,h2{font-size:40px;
            color:red;}
        /*类选择器*/
        .red{color: red}
        .blue{color: blue}
    </style>
</head>
<body>
<!--css命名 英文 数字 - _ 组成   以小写字母开头  不能用数字 - _开头-->
<h1>CSS层叠样式</h1>
<h2>CSS层叠样式</h2>

<p>用于定义HTML内容在浏览器中的显示样式</p>


<!--行内样式 直接在头标签加入style属性-->
<h1 style="font-family: Arial;color: red;">css使用方法</h1>

<!--内部样式  嵌入样式，把css样式代码写在style标签里，然后放到head标签内.见本文件head标签内-->
<style type="text/css">
    p{font-size:30px;
        color:blue;
        font-family: Arial}
</style>

<!--外部样式  新建一个 .css文件，在里面写css样式，然后引入文件  linke标签也放在head里面-->
<link rel="stylesheet" href="css.css" type="text/css">

<!--导入式  在style标签内写@import " "  放在head内-->
<style type="text/css">
    @import url(css.css);
    /*两种形式都可以，需要放在head内*/
    @import "css.css"
</style>

<!--优先级： 行内样式>内部样式>外部样式-->

<!--css选择器-->
<!--标签选择器  全局选择器  类选择器   群组选择器  ID选择器-->

<!--标签选择器  直接把标签作为选择器-->
    h1,h2{font-size:40px;color:red;}

<!--类选择器  为html标签添加class属性，用 .class 作为选择器-->
<h1 class="red">我是h1标签。我是类选择器，想变成红色</h1>
<h1 class="blue">我也是h1标签。我想变成蓝色</h1>
<style type="text/css">
    .red{color: red}
    .blue{color: blue}
    /*对于不同类型元素的同一个名称类选择器设置不同的样式*/
    p.red{color: red}
    p.one{text-decoration: gray}
    h2.blue{color: blue}
</style>
<!--一个标签多个类属性用空格隔开-->
<p class="blue one"></p>

<!--id选择器  为html标签添加id属性，和类选择器用法类似  用 #id  作为选择器   每个元素id唯一，不能设置多个id-->
<p id="p1">我是id选择器，我的id是p1</p>
<style type="text/css">
    #p1{color: red}
</style>

<!--群组选择器   不管是标签，类，id选择器，都可以用逗号隔开，进行群组设置-->
<!--全局选择器  用 * 代表所有内容-->
<style type="text/css">
    p.one,#p1,h1{font-size: 50px}
    *{color: red}
</style>

<!--后代选择器  对于某个标签下的某种子标签设置样式， 父标签 子标签{}   可以多层嵌套 同样父标签子标签都可以是标签选择器，类选择器或者id选择器-->
<p> <em>em放在p里面。em是p标签的子标签，p是em标签的父标签</em> </p>
<h1> <em>下面的css只会对p下的em起作用</em> </h1>
<h2 class="one"> <em>.one p em只对h2里面p里面的em生效</em>  <p> <em> 父选择器是类选择器</em> </p> </h2>
<style type="text/css">
    p em{font-size: 50px;}
    .one p em{font-family: Arial}
</style>

<!--伪选择器  定义特殊状态下的样式，无法用标签，id，class及其他属性实现-->
<!--例如 链接a的伪类  :link未访问的链接  :visited已访问的链接   :hover鼠标悬停状态   :active激活的链接（点下鼠标松开之前）-->
<!--其中 :hover   :active对于很多其他元素都可以使用 例如 p h1-->
<a href="http://www.imooc.com" target="_blank">访问慕课网</a>
<p>慕课网</p>
<p> <a href="http://www.imooc.com" target="_blank" class="red">访问慕课网</a> </p>

<style type="text/css">
    /*链接的伪类必须严格按照顺序，不然就会失效 :link > :visited > :hover > :active*/
    a:link{color: red}
    a:visited{color: gray}
    a:hover{color: white}
    a:active{color: aqua}
    p:hover{color: antiquewhite}
    /*也可通过 类选择器 后代选择器等多种方式 设置伪样式 可用于区分两个都为a链接但是链接内容不同的标签*/
    p a.red:hover{color: red}
</style>

<!--css属性的继承   子标签会继承副标签的属性-->
<div>
    <p>CSS <span>继承</span></p>
    <div>CSS层叠</div>
    <h1>h标签自带默认样式，会与父类继承的属性叠加</h1>
</div>
<h2>CSS继承和层叠</h2>

<style type="text/css">
    /*上面h1标签内字体会是24px，因为h1默认font-size：2em，即原始字体大小的两倍，从父类继承来12px*/
    div {font-size: 12px;
        border: 1px solid red;
    }
    /*只给"css层叠"这个附加绿色边框， 同时这个元素又继承了父标签的字体大小属性*/
    div div{
        border: 2px solid green;
    }
    /*层叠 是指对同一个元素定义多个冲突样式，就近原则，应用最后定义的那个。没有冲突就都会应用。 以下会让h2有金边框和蓝色字体*/
    h2{color: red; border: 2px solid gold}
    h2{color: blue; }
</style>

<!--css选择器优先级  -->
<style type="text/css">
    div{color: red}
    #idgreen{color: green}
    .classblue{color: blue}
    .classyellow{color: yellow}
</style>
<!--同一个元素用不同选择器 id选择器>class选择器>标签选择器   不管标签内id和class哪个属性放前面，都是id优先-->
<div>使用标签选择器 红色</div>
<div id="idgreen">使用id选择器 绿色</div>
<div class="classblue">使用class选择器 蓝色</div>
<div id="idgreen" class="classblue">同一个元素用标签 id  class样式</div>
<!--对同一个元素用同一种选择器 与两个样式在标签内顺序无关  取决于style中两个样式的顺序，就近原则。  标签选择器，id选择器，同理-->
<!--以下两个div效果一样，都是黄色，因为style里classyellow在后面-->
<div class="classblue classyellow">蓝色在前 黄色在后  是黄色</div>
<div class="classyellow classblue">黄色在前 蓝色在后 还是黄色</div>

<!--特殊 派生选择器的优先级-->
<!-- ！important 声明最高    标签选择器 1    类选择器和伪类 10  ID选择器 100   通配符选择器 0   行内样式 1000-->
<style type="text/css">
    p b{color: yellow;}  /*权值 1 + 1 = 2*/
    b{color: purple;}    /*权值 1*/
    .classred {color: red} /*权值 10*/
</style>
<div>
    <h1>派生选择器的优先级</h1>
<!--    以下第一个b采用yellow这个样式，因为他的权值是2。   第二个b标签，采用red，因为他的权值是10-->
    <p>所谓<b>css优先级</b>是指 <b class="classred">css样式</b>在浏览器中被解析的先后顺序</p>
    <div><b>权值相同</b>就近原则；<b>权值不同</b>那个权值高用哪个</div>
</div>


<!--文字样式-->
<style type="text/css">
    /*font-family是字体，可以设置多个，浏览器优先找第一个，找不到就找第二个，顺序查找。*/
    /*字体最好用引号包围，字体名称间有空格，必须用引号。最后可以加一个sans-serif字体集，这个字体集大多数浏览器都有且常用*/
    h1{font-family: "Times New Roman", "Arial",sans-serif}
    /*font-size文字大小 绝对单位有：in，cm，mm，pt，pc. 不能随着浏览器或者父类元素大小改变，所以通常不用绝对单位*/
    /*xx-small=9px x-small=11px small=13px medium=16px large=19px x-large=23px xx-large=28px*/
    /*相对单位有： px 像素值   % 百分比  smaller larger  像素值受显示器分辨率影响  百分比是相对于父类的百分比  smaller/larger相对于父类大小变化   */

    /*color 文字颜色， 颜色名称/RGB/十六进制       color：red   color:rgb(255,255,0)  color:rgb(0%,100%,50%)   color:#0008800*/

    /*font-weight文字粗细: normal=400默认 bold=700粗  bolder更粗  lighter更细 100~900   通常就用normal和bold 其他差别不大*/

    /*font-style文字样式  normal默认  italic斜体 oblique倾斜    可以用<em>或者<i>*/

    /*font-variant字体变形  normal  small-caps将大写字母变成小型的小写字母，即保持小写字母的大小，但是内容是大写字母*/

    /*简写以上所有文字样式 按照以下顺序写 font: font-style font-variant font-weight   font-size/line-height font-family*/
    /*其中前三个顺序可以交换，后两个必须严格遵守。  行高line-height可以跟size一起写，用斜线隔开*/
    p{font: italic bold small-caps 50px/1.5em "黑体","宋体";}
</style>

<!--文本样式-->
<style>
    /*text-align对齐方式: left左对齐 center居中 right右对齐  justify两端对齐*/

    /*line-height行高 长度值 百分比  长度值是固定的，字体变大也不会改变。 百分比用em或者%，当字体大小改变时，行高也可以改变*/
    /*text在content里面，行高为26px，但是最终text里面的字体会就近采用30px，字体大小大于行高，于是会产生重叠。 解决办法就是在text里面在设置line-height*/
    .content{font-size:20px;line-height:1.3em;}
    .text{font-size:30px;}

    /*vertical-align垂直对齐方式  baseline处于基线  sub  super  top行内元素最高位置对齐  text-top行内文本的顶端对齐  */
    /*middle在行内中部元素位置  bottom行内元素的底部  text-bottom行内文字的底部  长度（从基线向上+或向下-移动）  百分比（从基线向上+或向下-移动行高百分比的距离）*/

    /*word-spacing 单词间距   letter-spacing字母间距
    text-transform元素内文本的大小写转化 capitalize uppercase lowercase none：
    text-decoration元素内文本的装饰 underline下划线  overline上划线  line-through贯穿线  blink闪烁（很多时候不起作用）
          none链接自带下划线效果，想取消就给连接设置decoration为none   可以设置多个装饰，用空格隔开，但最后一个是none会把之前清空*/
    a{text-decoration: overline underline ;}
</style>
<!--要让以下content的内容在warp里居中显示-->
<div class="warp">
    <div class="content">
        <img src="../images/example/logo.png" alt="">
        <h1>welcome to website</h1>
        <h2>css层叠样式用于网页样式设置</h2>
    </div>
</div>
<!--对于单行元素，可以将line-height设置为行级元素例如p的height，从而达到居中显示的效果-->
<!--vertical-align只能作用于行级元素，middle是让他处于行内中部，显然content的div是个块级元素。所以就把他转化为table-cell，同时他的父容器需要转化为table-->
<style type="text/css">
    .warp{
        height:400px;
        width: 100%;
        border: 1px red solid;
        display: table;
    }
    .content{
        /*div变成了table-cell是行级元素，vertical-align才可以起作用   垂直居中*/
        vertical-align: middle;
        display: table-cell;
        /*text-align本身就是对多行文本元素起作用   水平居中*/
        text-align: center;
    }
</style>


<!----------------------------------------------------------------------------->
<!--盒子模型-->
<!--内部是element元素 元素的高height宽度width，元素与边框border之间是padding内边距，border与最外面是margin外边距-->
<!--width宽度  width：长度，百分比，auto   max-width：长度，百分比，auto     min-width：长度，百分比，auto-->
<style type="text/css">
    p{background-color: purple;width: 400px;}
    /*第一个盒子，只能是300，因为虽然设置p为400，但是限制了one的width只能是300。  如果最大为500，也只能是400*/
    .one{max-width: 300px}
    /*第二个盒子，可以到400，因为他只限制了最小宽度，统一设置的400还是符合要求的  如果最小为500，那就变成500*/
    .two{min-width: 250px}

    div{width: 600px;background-color: #acacac;}
    /*如果没有上面div 600的宽度设置，h1的50%是指浏览器的百分之五十，设置了父标签600px，则h1取父标签的百分之五十即300px*/
    h1{width: 50%; background-color: #ececec}
</style>

<p>盒子模型宽度哦width：400px；</p>
<p class="one">盒子模型最大宽度max-width：300px；</p>
<p class="two">盒子模型最小宽度min-width：250px；</p>
<div>
    <h1>如果父标签没有宽度限制，h1的50%是指浏览器的50%，设置了父标签，则h1取父标签的50%</h1>
</div>

<!--height高度  height：长度，百分比，auto   max-height：长度，百分比，auto     min-height：长度，百分比，auto-->
<!--对块级元素或替换元素进行高度设置。 基本同width设置-->
<!--width和height只能作用于块级元素p，div，h1～h6，ul，li，ol，dl，dt，dd等，如果不设置，默认为auto，width默认横向充满浏览器，height默认适应里面元素的内容-->
<!--也可作用于替换元素 <img><input><textarea>   不可作用于行级元素-->

<!--边框属性
边框宽度border-width：thin medium thick 长度值（em，px..）
边框颜色border-color：颜色 transparent（透明）    默认颜色跟标签内字体颜色一样
边框样式border-style：none默认无边框，所以必须设置style，不然看不到边框。   hidden与none相同，除非在表格元素中解决边框冲突问题
        dotted 点状边框 和 dashed虚线 多数浏览器呈实线。  solid实线（常用）  double双实线 groove 3d凹槽  ridge 3d垄状
        inset 3d inset边框   outset 3d outset边框  inherit从父类继承-->
<!--border-[left|right|top|bottom]-width|color|style   分别设置左右上下边框-->
<!--简写：  border：width｜style｜color      border-top｜left｜right｜bottom：width｜style｜color-->

<!--内边距属性-->
<!--padding-top｜left｜right｜bottom：长度值｜百分比    长度值不可为负-->
<!--网页中盒子的大小和height｜width和padding同时起作用。-->
<style type="text/css">
    /*div的总体高度为320px，总体宽度为330px*/
    .one{width:300px;height: 300px;background-color: #acacac;padding-top: 20px;padding-left: 30px}
    /*padding：值1  四个方向为值1                      padding：值1 值2；上下=值1 左右=值2*/
    /*padding：值1 值2 值3  上=值1  左右=值2  下=值3    padding：值1 值2 值3 值4   上右下左 逆时针*/
</style>

<!--外边距属性margin  值可以为负数  块级元素默认由margin属性，如果要去除，须覆盖margin：0-->
<!--margin-top｜left｜right｜bottom：长度值｜百分比｜auto  上右下左   -->
<!--auto，最外层元素，会在浏览器水平居中显示。  内层元素会相对于外层元素内水平居中显示。-->
<!--两个相邻块元素都设margin，则会重合，最终两个元素中间距离由最大的margin决定-->
<style type="text/css">
    /*两个块元素之间距离是30*/
    .one{margin-bottom: 20px}
    .two{margin-top: 30px}
</style>

<!--display属性-->
<style type="text/css">
    div,span{background-color: red;
    border: 1px #666 solid}
    /*将块级元素转化为行内元素，取消换行符。  转化为行内元素，不具有宽高属性值了*/
    div{display: inline}
    /*inline-block行内块元素，呈现为inline，但可以使用部分块级元素的属性，如宽高*/
    h1{display: inline-block}
    /*将行内元素转化为块级元素，增加换行    转化为块级元素，可以设置宽高属性值了*/
    span{display: block}
    /*a标签内的span不显示，鼠标经过的时候会显示为块级元素*/
    a span{display: none}
    a:hover span{display: block}
</style>
两个行内元素一起，中间会有个缝隙，解决办法，一，把两个元素放到同一个容器中。二，两个行内元素不换行，放一起
<div>display属性</div>
<div>display属性</div>

<span>display属性<span/>
<span>display属性<span/>
<!--方法一，放到同一个容器中-->
<div>
    <div>display属性</div>
    <div>display属性</div>
</div>
<!--方法二，行内元素间不换行-->
<span>display属性<span/><span>display属性<span/>

<!--小结：width和height只对块级元素替换元素起作用，
width，height，padding，margin，border都不继承父元素，需要通过inherit继承 如：div{padding：10px}   div p{padding:inherit}-->


<!--背景样式    背景包括内容、内边距padding、边框 不包含外边距margin-->
<!--background-color background-image background-position（背景图片的起始位置） background-attachment（背景图像是否固定还是随着页面其他部分滚动
background-repeat（背景图像是否重复及如何重复） background（简写）-->
background-color：颜色｜transparent。
background-image URL｜none  默认背景图像位于元素的左上角，并在水平和垂直方向重复复制
<!--背景颜色和图片都设置的时候，图片会覆盖背景颜色，如果图片加载不出来就会展现背景颜色-->
background-repeat：repeat｜no-repeat|repeat-x|repeat-y  在x或者y方向重复
background-attachment：scroll｜fixed   滚动（默认）｜固定（滚动窗口，图片一直固定在浏览器上）
background-position：百分比｜值｜top｜right｜bottom｜left｜center       top顶部居中  其他几个同理，一个方向固定，另一个方向居中。可以top left同时使用
    （x，y）水平，垂直。左上角0，0。 只写一个，第二个默认居中。  （x%，y%）水平，只写一个第二个居中。左上角0%，0%
background：[background-color][background-image][background-repeat][background-attachment][background-position]  简写不分先后顺序，空格分割

<!--列表样式     配合ul（无序列表）和ol（有序列表）标签使用-->
<!--list-style-type（列表项开头的标志类型，点，方块，空心圆）  list-style-image（把图片作为列表项标志）
list-style-position（列表项标志位置）  list-style简写-->
list-style-type：关键字｜none
    关键字  有序：decimal（数字）lower/upper-roman（罗马） lower/upper-alpha（英文）  无序：disc实心圆（默认）  circle空心圆  square实心方块
list-style-image：URL|none    url()
list-style-position: inside|outside     对于多行文本才明显
    inside标记在文本内，占用文本位置，环绕文本，根据标记对齐   outside默认，标记在文本外，不占文本位置，环绕文本，但不根据标记对齐
list-style：简写，type，image，position用空格隔开，不分先后，但是image会覆盖type

CSS浮动
CSS定位机制：普通流（标准流，默认，左到右，上到下）  浮动（只能左右）  绝对定位
    块元素：div,p,h1~h6,ul,ol,li,dl.dt,dd，独占一行，可设置宽高，不设置宽度默认宽度为容器的100%
    行元素：span,a,b,i,u,em...与其他元素同行显示，不可设置宽高，宽高就是里面文字或图片宽高
    float: left|right|none
    浮动元素脱离标准流,只能左右移动排序，碰到另一个包含框或另一个浮动框，浮动停止。第一个浮动元素寻找父容器的边，第二个浮动元素碰到第一个就停下。
    浮动元素只会影响之后的元素，之后的元素会环绕他，之前的不产生影响
    浮动之后的元素会具有inline-block的属性
<style type="text/css">
    .container{width:800px;height: 600px;border: 2px solid red}
    .container img{float:left;}
</style>
<div class="container">
<!--    浮动元素之前的p，不受影响，还是单独占整个行-->
        <p><p>ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编
        码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646。ASCII第一次以规范标
        准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符 [1] </p>
        <img src="../images/example/testpic.jpg" alt="" height="100px" width="400px">
<!--    浮动元素之后的p，内容会环绕浮动元素img，img在左边浮动。文本内容就会在右边环绕，然后换行到下面-->
        <p>ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编
            码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646。ASCII第一次以规范标
            准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符 [1] </p>
</div>

<!--元素浮动之后会脱离普通流。如果box1和box2都不浮动，外层div的border高度是自动，会把两个box都包围起来，为200。都设置浮动之后，border的高度会变为0
这就是高度塌陷。  可以通过给父容器设置height来消除这个影响-->
<!--    脱离父容器还表现为，如果只对box1设置浮动，box2不浮动，则box1会覆盖住box2。因为box1脱离了普通流，浮动去寻找父容器的边界-->
    <style type="text/css">
        .container{width: 500px;border: 2px solid #333;}
        .box01{width:100px; height: 100px; background: blue; color:#fff; float:left;}
        .box02{width:130px; height: 100px; background: red; color:#fff; }
    </style>
    <div class="container">
        <div class="box01">11111</div>
        <div class="box02">22222</div>
    </div>



<!--    清除浮动-->
<!--    clear: none|left|right|both   浮动元素会影响相邻元素，clear清除后只会影响自身，不会影响相邻元素-->
<style type="text/css">
    .clear{clear:both}       /*方法一：在浮动元素后面加上一个空的div，通过这个空div设置清楚浮动语法  clear：both*/
    .clearfix:after{content: "."; height: 0; display: block; visibility: hidden; clear: both;}
                            /*方法3：使用css3的  :after  伪元素，给浮动元素的容器添加一个隐藏的容器。用来消除浮动*/
    .container{width: 500px;border: 2px solid #333;    overflow: hidden}   /*方法二：给浮动元素的父级容器添加 overflow：hidden*/
    .box01{width:100px; height: 100px; background: blue; color:#fff; float: left; clear: both} /*方法四：直接清除该元素的浮动*/
    /*注意，先float：right，然后clear：both/right  之后，该元素会保留一个靠右对齐的格式*/
    .box02{width:100px; height: 100px; background: red; color:#fff; float: left;}
    .box03{width:100px; height: 100px; background: orange; color:#fff; float: left;}
    .box04{width:500px; height: 200px; background: green; color:#fff;}
</style>


<div class="container clearfix">
    <div class="box01">11111</div>
    <div class="box02">22222</div>
    <div class="box03">33333</div>
    <div class="clear"></div>
</div>
<div class="box04">44444</div>

    对于伪元素:after清除浮动解释
    原理跟在方法一相同，也是在aisde后面加一个空的div标签，然后对这个div清除。但是这样需要加入一个div。伪元素：after相当于在aside后面插入一个元素，
    但是不会写出来。 我们把这个元素内容写空，然后clear：both。  header::after是在header 的最后添加，即aside后面
    <style type="text/css">
        header{background: #abcdef}
        /*如果不清除浮动，header的背景颜色无法显示，即header没有被撑起来*/
        header::after{
            display: block;
            content: "";
            clear: both;
        }
        header > article{
            float: left;
            width: 40%;
            height: 30px;
            background: #ff0000;
        }
        header > aside{
            float: right;
            width: 40%;
            height: 50px;
            background: #1a5acd;
        }
    </style>

    <header>
        <article></article>
        <aside></aside>
    </header>



position  定位
作为模块：Position Layout Module提供与元素定位和层叠相关功能，他是一个核心模块
作为属性： .box{position:relative;}
static自然模型      relative相对定位模型   absolute绝对定位模型  fixed固定定位模型   sticky磁贴定位模型   inherit继承父类

    static：元素处于自然流/常规流排列 1。可以使当前元素忽略top｜bottom｜left｜right或者z-index声明，回到自然流。  其他元素如果不是在自然流中，就会产生重叠
          2。相邻元素最终外边距等于两者外边距中最大的  3。具有固定width和height的元素，如果左右边距为auto，则左右外边距自动扩大占满剩余宽度，效果就是水平居中

<style type="text/css">
    .block{
        top: 100px;   /*不起作用*/
        width: 50px;
        height: 50px;
        line-height: 50px;
        text-align: center;
        border: 2px solid blue;
        /*box-sizing: border-box;*/
    }
    /*nth-child(n)匹配其父级元素下的第n个元素，n可以是数字也可以是公式  如 p：nth-child（2n +1）就是匹配奇数个的p*/
    .block:nth-child(2){
        border: 2px solid red;
        position: static;
    }
</style>
    <div class="block">A</div>
    <div class="block">B</div>
    <div class="block">C</div>
    <div class="block">D</div>

    relative：让元素成为可定位的祖先元素。 1。可以使用top｜bottom｜left｜right｜z-index进行相对定位  设置偏移之后，元素位置会偏移，但是，他的空间还是在自然流中
    2。相对定位的元素不会离开自然流       元素偏移了，他的空间还预留在自然流中，其他元素无法填充
    3。任何元素都可以设置为relative，他的绝对定位藕带可以相对于他进行绝对定位。 ---用得多
    4。可以让浮动元素发生偏移，并控制他们的堆叠顺序   这个偏移还是相对于浮动元素本来的位置，自然流中的位置，进行偏移
<style type="text/css">
        .block{
            width: 50px;
            height: 50px;
            line-height: 50px;
            text-align: center;
            border: 2px solid blue;
            /*对于浮动元素，可以通过设置相对位置，对于该元素本来在自然流中的位置进行偏移，达到排列浮动元素，甚至是堆叠的目的*/
            float: left;
            /*在z方向进行偏移*/
            z-index:9;
        }
        .block:nth-child(2){
            position: relative;
            /*设置向下和向右的一个偏移（上和下多一个边）*/
            top: 20px;
            left: 20px;
            border: 2px solid red;
            z-index:-1;
        }
    </style>
<div class="block">A</div>
<div class="block">B</div>
<div class="block">C</div>

    absolute：让元素脱离常规流
    1。设置尺寸之一百分比的是谁，最近定位的祖先元素(注意最近定位的含义，就是不光是父元素，还要求他的父元素有定位)
        若直接父系元素没有定位，则会找父元素的父元素，一直往上找。  且父元素必须是除了static以外的定位属性
        所以通常，将relative和absolute结合使用，父元素设置为relative，使其相对于自然流的位置偏移，然后其子元素相对于父元素重新定位
        就达到了，一个元素依附于另一个元素的效果
    2。如果lrtb设置为0，则他将对齐到最近定位的祖先元素的各边
    3。lrtb如果设置为auto，则会打回原形。  4。如果没有最近定位的祖先元素，则为body   5。z-index可以控制堆叠顺序

<style type="text/css">
        .parent{
            position: relative;
            top:200px;
            left:200px;
            width: 200px;
            height: 150px;
            background: red;
        }
        .block{
            width: 50px;
            height: 50px;
            line-height: 50px;
            text-align: center;
            border: 2px solid blue;
            /*同样可以设置z-index偏移*/
            z-index:-1;
        }
        .block:nth-child(2){
            position: absolute;
            /*这个偏移是相对于父容器的偏移*/
            top: 20px;
            left: -20px;
            /*相对于父容器的50%*/
            width: 50%;
            border: 2px solid black;
            z-index:999999;

        }
        .block:nth-child(3){
            position: absolute;
            border: 2px solid green;
            z-index:999999;
            /*对于不设置宽高的元素（最上面block通用的宽高需要取消掉）。同时lrtb和margin都设置为0（margin：auto一样），则会达到自动填充整个最近定位父元素的效果*/
            /*如果设置了固定宽高，lrtb都设置为0。然后margin左右/上下设置为0/auto，那么auto的那一个方向会达到居中的效果。相当于，0的那个方向要求与父容器0距离，另一个
            方向就会自动填充。  如果宽高小于父容器，同时要求左右/上下0距离，会优先左/上两个边对齐*/
            top:0px;
            left:0px;
            right:0px;
            bottom:0px;
            margin:0 auto;
        }
    </style>
    <div class="parent">
        <div class="block">A</div>
        <div class="block">B</div>
        <div class="block">C</div>
    </div>

    fixed 固定定位   脱离自然流
    1。跟absolute的区别在于对谁做绝对定位。  absolute是相对于最近定位的父元素绝对。fixed是相对于当前视窗。滑动视窗位置不会变。
    2。固定定位的元素不会随视窗的滚动而滚动
    3。继承absolute的特点  除了不随视窗滚动，其他跟absolute一样
<style type="text/css">
        .block{
            width: 50px;
            height: 50px;
            line-height: 50px;
            text-align: center;
            border: 2px solid blue;
        }
        .block:nth-child(1){
            position: absolute;
            top: 20px;
            left: 20px;
            border: 2px solid red;
        }
        .block:nth-child(2){
            position: fixed;
            top: 20px;
            left: 20px;
            border: 2px solid red;
        }
    </style>
<div class="block">固定定位</div>
<div class="block">绝对定位</div>

    sticky 磁贴布局/粘性定位/吸附定位   relative+fixed的结合。制造出吸附效果
    1。如果偏移，原位置还会在常规流。
    2。他的最近定位祖先有滚动，那么他偏移标准就是最近的定位祖先元素。
    3。如果最近祖先元素没有滚动，那么偏移就是视窗
    4。上下左右偏移规则
    <style type="text/css">
        .logo{
            width: 100%;
            height: 50px;
            background-color: gray;
        }
        .nav{
            position: sticky;
            /*相当于以最近定位父元素顶部为基准线，画一个矩形，宽度就是父元素宽度，高度就是top。然后当滚动视窗，此sticky的元素碰到这个矩形，就会偏移。无法与这个矩形重合。*/
            top:30px;
            width: 100%;
            height: 50px;
            background-color: blue;
            color: #ffffff;
            cursor: pointer;
        }
        .content{
            height: 300px;
            overflow: scroll;
            background-color: yellow;
        }
    </style>
<div class="logo">想象我是网站头图</div>
<div class="nav">想象这里是一堆banner 导航图 ｜ 分享  ｜ 收藏</div>
<div class="content">
    <p>假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
        假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
        假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
    </p>

    <div class="nav">想象这里是一堆banner 导航图 ｜ 分享  ｜ 收藏</div>

    <p>假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
        假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
        假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。</p>
    <p>假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
        假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
        假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。</p>
    <p>假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
        假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
        假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。</p>
    <p>假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
        假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。
        假装自己是一段文字。假装自己是一段文字。假装自己是一段文字。</p>
</div>




<!------------------------------------------------------------------------------------------------------------------------>
<!------------------------------------------------------------------------------------------------------------------------>
<!------------------------------------------------------------------------------------------------------------------------>
<!------------------------------------------------------------------------------------------------------------------------>
<!--css3-->
css3选择器：
    子元素选择器：只能选择某元素的子元素(必须是紧邻的，直系子元素)     Father > Child
    相邻兄弟元素选择器：选择该元素之后的一个元素，他们具有相同父亲（仅限接下来的第一个）        Element + Sibling
    通用兄弟元素选择器：该元素之后的所有元素，他们具有相同的父亲        Element～Sibling
    群组选择器：可以把要设置相同的元素分组在一起，每个元素用"，"隔开(每个元素的选择器可以不同类别)    Element1,Element2,Element3

    属性选择器：
    a[href]{ text-decoration: none}             选择带有href属性的a标签
    <a href="index.html">选择带有href属性的a标签</a>
    a[href="value"]{ text-decoration: none}        选择带有属性href，且href="value"的标签
    a[href～="value"]{ text-decoration: none}       包含value这个属性（多个属性用空格隔开的情况）  例如 href～="two"，可以匹配 one two 不能匹配onetwo
    a[href*="value"]{ text-decoration: none}        属性包含子串value  例如 href～="room"，可以匹配 myroom   *=用的比～=多
    a[href^="value"]{ text-decoration: none}        value开头   例如 href^="#"，可以匹配 #1 #2 #3
    a[href$="value"]{ text-decoration: none}        value结尾   例如 href$="#"，可以匹配 1# 2# 3#
    a[href｜="value"]{ text-decoration: none}       以value-开头，或者只有value   例如 href$="#"，可以匹配 #-1 #

    动态伪类选择器：(并不存在于html中，只有用户与网站交互时体现)
        锚点伪类：:link|:visited      链接默认｜访问过
        用户行为伪类：:hover|:active|:focus   鼠标选中｜鼠标点击｜输入框光标进入

    UI元素状态伪类：:enable|:disabled|:checked   可输入｜不可输入｜选中的
        input{}其实默认等于  input:enable{}   input:disable{ }可以修改<input type="text" disabled="disabled">的属性
    CSS3结构类： :nth选择器
        选择方法 :first-child（其父元素的的首个子元素的所有Element）  :last-child（其父元素的最后一个子元素的所有Element）
                :nth-child(N)（其父元素的第N个子元素，不论类型）
                括号里面可以输入数字，表示第N个。 也可以输入n或者n的表达式（必须用n，不能是其他字符），其中n从0开始取值。 如： 4n-1  n*n   也可以是even odd
                :nth-last-child(N)（其父元素的第N个子元素的所有元素，从最后一个子元素开始计数） 同理可以写n的表达式
                :nth-of-type(N) （其父元素的特定类型的第N个子元素的所有元素。这个特定类型就是 ：nth-of-type前面那个元素类型）
                :nth-last-of-type() （从最后一个元素开始计数）
                :first-of-type（其父元素的特定类型的首个子元素的所有元素）
                :last-of-type  （其父元素的特定类型的首个子元素的所有元素）
                :only-child （其父元素的唯一子元素的所有元素，如果父元素下有多个child，则不匹配）
                :only-of-type  （其父元素的唯一子元素的所有元素，如果父元素下有多个这种类型的标签，则不匹配）
                :empty （匹配没有子元素（包括文本节点的）所有元素）相当于直接选取全空的标签
    否定选择器： :not(Element/selector)匹配非指定元素/选择器的所有元素    Father:not(children/selector)

    伪元素：css伪元素用于向某些选择器设置特殊效果   Element::pseudo-element
        Element::first-line  first-line是伪元素，对element元素的第一行文本进行操作。前面的element是元素的选择器 （只能作用于块级元素）
        Element::first-letter  对第一个字母（汉字）操作 （只能作用于块级元素）
        Element::before  在元素前面插入新内容    <div>伪元素</div>   div::before{content:"新元素"  color：red}  最后显示：新元素伪元素。 新元素为红色
                before里的内容永远在这个div最前面，默认为行级元素，可以display：block。 内容通过content写入，可以在里面继续写这个元素的样式
        Element::after 在元素内容后面插入新内容，性质和before一样。   配合content使用，多用于清除浮动。
        Element::selection 用于设置在浏览器中选中文本后的背景色和前景色（对IE的兼容性不好）
            div::selection{background:red ; color:gold}  这个div里面的文字被选取的时候，背景是红色，文字是金色

    css权重：
        行内样式（1000）> ID选择器（100） > 类、属性选择器、伪类选择器（10）> 元素、伪元素（1） > *（0）
        直接写在标签内的直接生效， 嵌入式的，就近原则（越后面越生效）
        无论多少个选择器想加，都没有一个class选择器权重高

边框和圆角
    css3圆角
    border-radius:  可以拆分开例如border-top-left-radius左上角
        border-radius: 长度｜%    四个（左上｜右上｜右下｜左下）  三个（左上｜右上左下｜右下） 两个（左上右下｜右上左下） 一个（所有）
                        百分比是相对于元素本身的尺寸，所以当矩形长宽不一样的时候，可以形成椭圆的圆角。矩形四个角圆角都设置成50%会变成椭圆
    CSS3盒阴影
    box-shadow：可以设置一个或多个下拉阴影框
        box-shadow: 水平偏移px  垂直偏移px  模糊度px  大小px  颜色

    css3边界图片
    border-image-* ： 构建好看的可拓展按钮
    border-image： source（url（""）） slice（图片的边界向内偏移 值｜百分比｜fill） width（值｜百分比｜auto） outset repeat

背景
    background-clip：指定背景绘制区域
        background-clip：border-box（背景被裁减到边框盒）｜padding-box（裁减到内边距框）｜content-box（裁减到内容框）
    background-origin：对于background-position 属性的相对位置
        background-origin：border-box（背景被裁减到边框盒）｜padding-box（裁减到内边距框）｜content-box
        background含有background-position的属性，设置了background-origin之后，position里面的参数，就是相对于origin定义的选框的偏移
        例如：background：url（"bg.jpg"） no-repeat 50px 100px    background-origin：padding-box
                意思是，背景图片的左上角，相对于内边距框最左上角偏移 50px 100px
    background-size：大小
        background-size：长度值｜百分比｜cover｜contain   两个值，分别长宽。 只设置一个，另一个会等比例设置。cover填满。contain缩放至某一边紧贴容器
    多重背景: 允许设置多个背景
        background：url（img1.png）,url（img2.jpg） 前面一个会遮住后面这个。但是png允许有透明背景，所以吧png放前面，可以产生叠加
    背景属性简写：
        background：color｜position｜size｜repeat｜origin｜clip｜attachment｜image

渐变颜色
    linear gradients：线性渐变，从起点到终点，沿一根轴颜色渐变
        上下渐变（color可以为transparent）
        background：linear-gradient（direction，color-stop1，color-stop2，....）
        不同浏览器可能语法不一样
        background：linear-gradient（to right,red，blue）
        对角渐变
        background：linear-gradient（left top,red，blue）
        设置角度渐变
        background：linear-gradient（angle,red，blue）   0deg从下到上   90deg从左到右
        颜色结点分布（0%的位置是red，20%的位置是blue）
        background：linear-gradient（90deg,red 10%，blue 20%）
        重复渐变（0%red，10%blue，30%red，40%blue，60%red，.....）
        background：repeating——linear-gradient（90edg，red 0%，blue 10%，red 20%）
    radial gradients：径向渐变： 从起点到终点的颜色从内到外进行圆形渐变（从中往外拉）
        background：radial-gradient（center，shape size，color-stop1，color-stop2，。。。） shape可以为circle或ellipse（默认椭圆）
                size为closest-side最近边｜closest-corner最近角｜farthest-side最远边｜farthest-corner最远角。以最近/远的边/角为结束点
                注意size和shape是同一个属性，空格隔开，不能加逗号
        径向重复渐变：
        background：repeating——radial-gradient（color1 length｜百分比，color1 length｜百分比。。。）   形成很多同心圆

文本内容
    文本阴影：text-shadow
        text-shadow：h-shadow（水平偏移），v-shadow（垂直偏移） blur（模糊） color
    文本换行
        word-break：normal｜break-all（不管一个单词是否结束都会换行，哪怕拆开单词）｜keep-all（只在空格处换行）
        word-wrap：normal｜break-word   （normal，超长的单词或网址不会换行，break-word会换行）
    新属性：
        text-align-last：auto｜left｜right｜center｜justify｜start｜end｜initial｜inherit  最后一行的对齐方式，只有在text-align属性为justify的时候才有效果
        text-overflow：clip｜ellipsis｜string  文本溢出包含元素时发生的事情
@font-face
    @font-face语法：（创建一种字体，允许把字体保存到服务器，加载到网页）
        @font-face{
            font-family:<WebFontName>  必须设置，字体名称，自定义的
            src:<source>[<format>][,<source>[<format>]]*   必须设置，字体路径，可多个。 source可以绝对也可以相对，format是自定义字体格式，帮助浏览器识别
            font-weight:   (可以不设置) 是否粗体
            font-style:  （可以不设置） 斜体下划线等
        }
    @font-face格式：
            .ttf   RAW格式，是常见字体    .otf 原始字体格式    .woff是web字体中最佳格式。支持元数据包分离    .eot是IE专用字体   .svg基于svg字体渲染的格式
    @font-face应用：
            推荐，通用模版：
            @font-face{
                font-family: YourWebFontName
                src:url(YourWebFontName.eot);   /*IE9 compat modes*/
                src:url(YourWebFontName.eot?#iefix)format(embedded-opentype),  /*IE6-IE8*/
                    url(YourWebFontName.ttf)format(truetype),  /*safari,android,ios*/
                    url(YourWebFontName.woff)format(woff),  /*Modern Browsers*/
                    url(YourWebFontName.svg#YourWebFontName)format(svf),   /*legacy ios*/
            }
            h1 {font-family: YourWebFontName}
    获取特殊字体: https://www.fontsquirrel.com/tools/webfont-generator


CSS转换：
    很多css3样式具有兼容性问题，包括上述的一些属性。所以设置css的时候，可以采用如下方式，添加前缀支持：
            img {
                -webkit-transform:rotate(60deg);
                   -moz-transform:rotate(60deg);
                    -ms-transform:rotate(60deg);
                     -o-transform:rotate(60deg);
            }

    CSS3 Transform：让元素变形，包含变形参数，可以移动，旋转，缩放
        transform：none|<transfor-function>[<transfor-function>]*
    CSS3 2D转换：
        rotate() : 旋转    rotate（60deg） 正数顺时针，负数逆时针
        translate(): 平移  translateX(x)｜translateY(y) 仅x｜y轴方向移动    translate(x，y) 同时移动。只传一个参数默认y=0  数值为百分比或者长度值
        scale（）：缩放 scaleX(x)｜scaleY(y) 仅x｜y轴方向缩放    scale(x，y) 同时缩放。只传一个参数默认y=1   数值为百分比或者长度值
        skew（）：扭曲或斜切  skew（60deg）正数顺时针斜切，负数逆时针斜切 skewX（60deg）正数逆时针斜切，负数顺时针斜切  skewY与skewX相反
    CSS3 3D转换
        rotate3d（）: rotateX（60deg）｜rotateY｜rotateZ 绕X｜Y｜Z轴旋转角度。注意2d里面没有x，y，z参数
                rotate3d（x，y，z，angle）  四个参数都不能省略
        translate3d()：   translateZ（z）   x，y方向跟2d相同
        scale3d()： scaleZ（z）   x，y方向跟2d相同
    CSS3 Transform与坐标系统：
        transform-origin：x-axis y-axis z-axis    定义当前操作元素上某一个位置为原点。 注意是操控的元素，不是浏览器页面的。
                transform-origin：top left   以左上角为原点，进行旋转缩放等操作
    CSS3 扩展属性
        transform-style：指定嵌套元素是怎样在三维空间中呈现。  两个同心圆，进行3d旋转，必然会有一个在另一个上面，无法形成嵌套效果。 此时设置成preserve-3d可以解决
                transform-style：flat（默认）｜preserve-3d
        perspective：指定观察者与【z=0】平面的距离，使三维位置变换的元素产生透视效果
                perspective：number｜none
        perspective-origin：x-axis y-axis 指定透视点的位置。默认都是50%。   可以传参 l｜r｜t｜b。也可以两两结合  top相当于从上往下看
        backface-visibility：visible（默认）｜hidden 指定元素背面面向用户时是否可见

CSS过度 Transition
    Transition：允许css的属性值在一定时间区间内平滑过渡
    transition-property：none｜all（所有属性）｜property（某个具体属性，如color，opacity）
    transition-duration：time   过渡效果花费的时间，默认是0
    transition-timing-function: ease|linear|ease-in|ease-out|ease-in-out|step-start|step-end|steps(<integer>[,[start|end]]?)|
                                |cubic-bezier(<number>,<number>,<number>,<number>);    只能使用一个
            linear：线性过度 等同于贝塞尔曲线（0，0，1，1）     ease：平滑过渡（0.25,0.1,0.25,1）    ease-in:由慢到快  （0.42,0,1,1）
            ease-out：由快到慢（0，0，0.58,1）    ease-in-out：由慢到快再到慢。（0/42.0,0.58,1）
            step-start:等于steps（1，start）   step-end:等于steps（1，end）
            steps（<integer>[,[start|end]]?）:接受两个参数的步进函数，第一个参数为正整数，指定函数，第二个取值为start｜end，指定每一步的值发生变化的地点，第三个参数可选，默认为end
    transition-delay： time    （默认为0，单位s或者ms）  设置延迟过度的时间
    例子： div{width:800px; height: 800px ; margin : auto; transform: rotate(0deg); background:url(images/logo.png) no-repeat center
                      transition-property:transform;    /*同样前面可以加webkit。moz。ms。o的前缀增加兼容性*/
                  }
                  div:hover{cursor:pointer; transform:rotate(180deg)
                      transition-property:transform;
                      transition-duration: 2s;        /*可以是s或者ms*/
                      transition-timing-function：ease-in-out;
                      transition-delay:2s
                  }
    transition：property duration timing-function delay；  简写  顺序必须按照这个，不能错


CSS3动画

    CSS3 animation          手持设备上要加入webkit前缀
        animation-name：keyframename｜none   指定要绑定到选择器的关键帧的名称
        animation-duration: time   播放开始到完成花费的时间，默认0，没有动画
        animation—timing-function：ease|linear|ease-in|ease-out|ease-in-out|step-start|step-end|steps(<integer>[,[start|end]]?)|
                                |cubic-bezier(<number>,<number>,<number>,<number>);    只能使用一个
        animation-delay： time
        animation-iteration-count：infinite|<integer>   循环次数
        animation-direction：normal｜reverse｜alternate｜alternate-reverse｜initial｜inherit            normal正常方向  reverse反方向
              alternate先正常，再反向，交替运行   alternate-reverse先反向在正常，交替运行  （后面两个需控制iteration-count，不然无法循环交替）
        animation-fill-mode：none｜forwards｜backwards｜both｜initial｜inherit     规定动画不播放时（播放完成，或延迟未开始播放）应用的元素样式
              forwards：对象状态为动画结束时的状态   backwards：开始的状态   both：结束或开始
        animation-play-state：paused｜running（默认，指定正在运行的动画）     指定动画是否正在运行或者暂停。可以通过交互，例如：hover，修改值，控制什么时候运行什么时候暂停
        animation：name duration timing-function delay iteration-count direction fill-mode play-state
    CSS3 @keyframes       定义关键帧，指定任何顺序排列来决定动画变化的关键位置
                使用@keyframes规则创建动画，通过逐步改变从一个css样式设定到另外一个，在动画过程中通过@keyframes规则多次改变css样式的设定
        @keyframes animationname{                         /* animationname:必写，定义animation的名字，*/
                                 keyframes-selector{      /* keyframes-selector：必写，动画持续时间的百分比 0—100%，from（0%），to（100%）*/
                                     css-style            /* css-style：必写，一个或多个css样式*/
                                    }
                                 }
    CSS3 will-change：    提前告诉浏览器将要做什么动画，让浏览器提前准备合适的优化设置。增强页面渲染性能。 原理，普通css不会触法GPU的加速，而是用浏览器的
                          软件渲染引擎。 只有3d动画会有单独的layer，并且触发GPU，为元素添加没有变化的3d变形，骗取浏览器触发硬件加速 translateZ（） translate3d（） Hack
         will—change：auto｜scroll-position｜contents｜<custom-ident>｜<animateable-feature>
         三种优化：1，position-fixed代替 background-attachment   2，带图片的元素放在伪元素中   3，巧用will-change
                      auto没特定意图，通用，   scorll-position将改变元素滚动位置     contents将改变元素的内容
                      custom-ident明确指定件要改变的属性和给定的名称     animateable-feature给动画特征值，如left，top，margin等
    div > .inner{ background-image:url(images/logo.png);
                  animation-name:circle_inner;
                  animation-duration: 10s
                  }
    @keyframes circle_inner{
                  from {transform:rotateX(0deg);   }   /* 等同于0% */
                  25%  {transform:rotateX(45deg);   }
                  to   {transform:rotateX(360deg); }
                  }





















</body>
</html>